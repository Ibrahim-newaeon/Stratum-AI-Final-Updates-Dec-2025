{"version":3,"file":"cdp-B6W0ktOz.js","sources":["../../src/api/cdp.ts"],"sourcesContent":["/**\r\n * Stratum AI - CDP (Customer Data Platform) API Client\r\n *\r\n * API client with TypeScript types and React Query hooks for CDP endpoints.\r\n * Handles event ingestion, profile lookups, and source management.\r\n */\r\n\r\nimport { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport { apiClient, ApiResponse } from './client';\r\n\r\n// =============================================================================\r\n// TypeScript Types\r\n// =============================================================================\r\n\r\n// Identifier Types\r\nexport type IdentifierType = 'email' | 'phone' | 'device_id' | 'anonymous_id' | 'external_id';\r\n\r\nexport interface IdentifierInput {\r\n  type: IdentifierType;\r\n  value: string;\r\n}\r\n\r\nexport interface Identifier {\r\n  id: string;\r\n  identifier_type: IdentifierType;\r\n  identifier_value?: string;\r\n  identifier_hash: string;\r\n  is_primary: boolean;\r\n  confidence_score: number;\r\n  verified_at?: string;\r\n  first_seen_at: string;\r\n  last_seen_at: string;\r\n}\r\n\r\n// Event Types\r\nexport interface EventContext {\r\n  user_agent?: string;\r\n  ip?: string;\r\n  locale?: string;\r\n  timezone?: string;\r\n  screen?: { width: number; height: number };\r\n  campaign?: Record<string, string>;\r\n}\r\n\r\nexport interface EventConsent {\r\n  analytics?: boolean;\r\n  ads?: boolean;\r\n  email?: boolean;\r\n  sms?: boolean;\r\n}\r\n\r\nexport interface EventInput {\r\n  event_name: string;\r\n  event_time: string;\r\n  idempotency_key?: string;\r\n  identifiers: IdentifierInput[];\r\n  properties?: Record<string, unknown>;\r\n  context?: EventContext;\r\n  consent?: EventConsent;\r\n}\r\n\r\nexport interface EventBatchInput {\r\n  events: EventInput[];\r\n}\r\n\r\nexport interface EventIngestResult {\r\n  event_id?: string;\r\n  status: 'accepted' | 'rejected' | 'duplicate';\r\n  profile_id?: string;\r\n  error?: string;\r\n}\r\n\r\nexport interface EventBatchResponse {\r\n  accepted: number;\r\n  rejected: number;\r\n  duplicates: number;\r\n  results: EventIngestResult[];\r\n}\r\n\r\nexport interface CDPEvent {\r\n  id: string;\r\n  event_name: string;\r\n  event_time: string;\r\n  received_at: string;\r\n  properties: Record<string, unknown>;\r\n  context: Record<string, unknown>;\r\n  emq_score?: number;\r\n  processed: boolean;\r\n}\r\n\r\n// Profile Types\r\nexport type LifecycleStage = 'anonymous' | 'known' | 'customer' | 'churned';\r\n\r\nexport interface CDPProfile {\r\n  id: string;\r\n  tenant_id: number;\r\n  external_id?: string;\r\n  first_seen_at: string;\r\n  last_seen_at: string;\r\n  profile_data: Record<string, unknown>;\r\n  computed_traits: Record<string, unknown>;\r\n  lifecycle_stage: LifecycleStage;\r\n  total_events: number;\r\n  total_sessions: number;\r\n  total_purchases: number;\r\n  total_revenue: number;\r\n  identifiers: Identifier[];\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface ProfileListResponse {\r\n  profiles: CDPProfile[];\r\n  total: number;\r\n  page: number;\r\n  page_size: number;\r\n}\r\n\r\n// Source Types\r\nexport type SourceType = 'website' | 'server' | 'sgtm' | 'import' | 'crm';\r\n\r\nexport interface SourceCreate {\r\n  name: string;\r\n  source_type: SourceType;\r\n  config?: Record<string, unknown>;\r\n}\r\n\r\nexport interface CDPSource {\r\n  id: string;\r\n  name: string;\r\n  source_type: SourceType;\r\n  source_key: string;\r\n  config: Record<string, unknown>;\r\n  is_active: boolean;\r\n  event_count: number;\r\n  last_event_at?: string;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface SourceListResponse {\r\n  sources: CDPSource[];\r\n  total: number;\r\n}\r\n\r\n// Consent Types\r\nexport type ConsentType = 'analytics' | 'ads' | 'email' | 'sms' | 'all';\r\n\r\nexport interface ConsentUpdate {\r\n  consent_type: ConsentType;\r\n  granted: boolean;\r\n  source?: string;\r\n  consent_text?: string;\r\n  consent_version?: string;\r\n}\r\n\r\nexport interface CDPConsent {\r\n  id: string;\r\n  consent_type: ConsentType;\r\n  granted: boolean;\r\n  granted_at?: string;\r\n  revoked_at?: string;\r\n  source?: string;\r\n  consent_version?: string;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\n// EMQ Score Types\r\nexport interface EMQScore {\r\n  overall_score: number;\r\n  identifier_quality: number;\r\n  data_completeness: number;\r\n  timeliness: number;\r\n  context_richness: number;\r\n}\r\n\r\n// Health Check Response\r\nexport interface CDPHealthResponse {\r\n  status: 'healthy' | 'degraded' | 'unhealthy';\r\n  module: string;\r\n  version: string;\r\n}\r\n\r\n// Webhook Types\r\nexport type WebhookEventType =\r\n  | 'event.received'\r\n  | 'profile.created'\r\n  | 'profile.updated'\r\n  | 'profile.merged'\r\n  | 'consent.updated'\r\n  | 'all';\r\n\r\nexport interface WebhookCreate {\r\n  name: string;\r\n  url: string;\r\n  event_types: WebhookEventType[];\r\n  max_retries?: number;\r\n  timeout_seconds?: number;\r\n}\r\n\r\nexport interface WebhookUpdate {\r\n  name?: string;\r\n  url?: string;\r\n  event_types?: WebhookEventType[];\r\n  is_active?: boolean;\r\n  max_retries?: number;\r\n  timeout_seconds?: number;\r\n}\r\n\r\nexport interface CDPWebhook {\r\n  id: string;\r\n  name: string;\r\n  url: string;\r\n  event_types: WebhookEventType[];\r\n  secret_key?: string; // Only returned on create/rotate\r\n  is_active: boolean;\r\n  last_triggered_at?: string;\r\n  last_success_at?: string;\r\n  last_failure_at?: string;\r\n  failure_count: number;\r\n  max_retries: number;\r\n  timeout_seconds: number;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface WebhookListResponse {\r\n  webhooks: CDPWebhook[];\r\n  total: number;\r\n}\r\n\r\nexport interface WebhookTestResult {\r\n  success: boolean;\r\n  status_code?: number;\r\n  response_time_ms?: number;\r\n  error?: string;\r\n}\r\n\r\n// Anomaly Detection Types\r\nexport type AnomalySeverity = 'low' | 'medium' | 'high' | 'critical';\r\nexport type AnomalyDirection = 'high' | 'low';\r\n\r\nexport interface EventAnomaly {\r\n  source_id?: string;\r\n  source_name: string;\r\n  metric: string;\r\n  zscore: number;\r\n  severity: AnomalySeverity;\r\n  current_value: number;\r\n  baseline_mean: number;\r\n  baseline_std: number;\r\n  direction: AnomalyDirection;\r\n  pct_change: number;\r\n}\r\n\r\nexport interface AnomalyDetectionResponse {\r\n  anomalies: EventAnomaly[];\r\n  anomaly_count: number;\r\n  has_critical: boolean;\r\n  has_high: boolean;\r\n  analysis_period_days: number;\r\n  zscore_threshold: number;\r\n  total_sources_analyzed: number;\r\n}\r\n\r\nexport interface AnomalyDetectionParams {\r\n  window_days?: number;\r\n  zscore_threshold?: number;\r\n}\r\n\r\nexport type HealthStatus = 'healthy' | 'fair' | 'degraded' | 'critical' | 'unknown';\r\nexport type VolumeTrend = 'increasing' | 'stable' | 'decreasing';\r\n\r\nexport interface AnomalySummaryResponse {\r\n  health_status: HealthStatus;\r\n  events_today: number;\r\n  events_7d: number;\r\n  events_prev_7d: number;\r\n  wow_change_pct: number;\r\n  volume_trend: VolumeTrend;\r\n  avg_emq_score?: number;\r\n  as_of: string;\r\n}\r\n\r\n// Identity Graph Types\r\nexport type IdentityLinkType =\r\n  | 'same_session'\r\n  | 'same_event'\r\n  | 'login'\r\n  | 'form_submit'\r\n  | 'purchase'\r\n  | 'manual'\r\n  | 'inferred';\r\n\r\nexport type MergeReason = 'identity_match' | 'manual_merge' | 'login_event' | 'cross_device';\r\n\r\nexport interface IdentityGraphNode {\r\n  id: string;\r\n  type: IdentifierType;\r\n  hash: string;\r\n  is_primary: boolean;\r\n  priority: number;\r\n}\r\n\r\nexport interface IdentityGraphEdge {\r\n  source: string;\r\n  target: string;\r\n  type: IdentityLinkType;\r\n  confidence: number;\r\n}\r\n\r\nexport interface IdentityGraphResponse {\r\n  profile_id: string;\r\n  nodes: IdentityGraphNode[];\r\n  edges: IdentityGraphEdge[];\r\n  total_identifiers: number;\r\n  total_links: number;\r\n}\r\n\r\nexport interface CanonicalIdentity {\r\n  id: string;\r\n  profile_id: string;\r\n  canonical_type?: IdentifierType;\r\n  canonical_value_hash?: string;\r\n  priority_score: number;\r\n  is_verified: boolean;\r\n  verified_at?: string;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface ProfileMergeRequest {\r\n  source_profile_id: string;\r\n  target_profile_id: string;\r\n  reason?: string;\r\n}\r\n\r\nexport interface ProfileMerge {\r\n  id: string;\r\n  surviving_profile_id?: string;\r\n  merged_profile_id: string;\r\n  merge_reason: MergeReason;\r\n  merged_event_count: number;\r\n  merged_identifier_count: number;\r\n  is_rolled_back: boolean;\r\n  created_at: string;\r\n}\r\n\r\nexport interface ProfileMergeHistoryResponse {\r\n  merges: ProfileMerge[];\r\n  total: number;\r\n}\r\n\r\nexport interface IdentityLink {\r\n  id: string;\r\n  source_identifier_id: string;\r\n  target_identifier_id: string;\r\n  link_type: IdentityLinkType;\r\n  confidence_score: number;\r\n  is_active: boolean;\r\n  evidence: Record<string, unknown>;\r\n  created_at: string;\r\n}\r\n\r\nexport interface IdentityLinksResponse {\r\n  links: IdentityLink[];\r\n  total: number;\r\n  limit: number;\r\n  offset: number;\r\n}\r\n\r\n// Segment Types\r\nexport type SegmentType = 'static' | 'dynamic' | 'computed';\r\nexport type SegmentStatus = 'draft' | 'computing' | 'active' | 'stale' | 'archived';\r\n\r\nexport interface SegmentCondition {\r\n  field: string;\r\n  operator: string;\r\n  value: unknown;\r\n}\r\n\r\nexport interface SegmentRules {\r\n  logic: 'and' | 'or';\r\n  conditions: SegmentCondition[];\r\n  groups?: SegmentRules[];\r\n}\r\n\r\nexport interface SegmentCreate {\r\n  name: string;\r\n  description?: string;\r\n  segment_type?: SegmentType;\r\n  rules: SegmentRules;\r\n  tags?: string[];\r\n  auto_refresh?: boolean;\r\n  refresh_interval_hours?: number;\r\n}\r\n\r\nexport interface SegmentUpdate {\r\n  name?: string;\r\n  description?: string;\r\n  rules?: SegmentRules;\r\n  tags?: string[];\r\n  auto_refresh?: boolean;\r\n  refresh_interval_hours?: number;\r\n}\r\n\r\nexport interface CDPSegment {\r\n  id: string;\r\n  name: string;\r\n  slug?: string;\r\n  description?: string;\r\n  segment_type: SegmentType;\r\n  status: SegmentStatus;\r\n  rules: Record<string, unknown>;\r\n  profile_count: number;\r\n  last_computed_at?: string;\r\n  computation_duration_ms?: number;\r\n  auto_refresh: boolean;\r\n  refresh_interval_hours: number;\r\n  next_refresh_at?: string;\r\n  tags: string[];\r\n  created_by_user_id?: number;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface SegmentListResponse {\r\n  segments: CDPSegment[];\r\n  total: number;\r\n}\r\n\r\nexport interface SegmentPreviewRequest {\r\n  rules: SegmentRules;\r\n  limit?: number;\r\n}\r\n\r\nexport interface SegmentPreviewResponse {\r\n  estimated_count: number;\r\n  sample_profiles: CDPProfile[];\r\n}\r\n\r\nexport interface SegmentProfilesResponse {\r\n  profiles: CDPProfile[];\r\n  total: number;\r\n}\r\n\r\nexport interface ProfileSegmentsResponse {\r\n  segments: CDPSegment[];\r\n}\r\n\r\n// Computed Traits Types\r\nexport type TraitType =\r\n  | 'count'\r\n  | 'sum'\r\n  | 'average'\r\n  | 'min'\r\n  | 'max'\r\n  | 'first'\r\n  | 'last'\r\n  | 'unique_count'\r\n  | 'exists'\r\n  | 'formula';\r\n\r\nexport interface ComputedTraitSourceConfig {\r\n  event_name?: string;\r\n  property?: string;\r\n  time_window_days?: number;\r\n}\r\n\r\nexport interface ComputedTraitCreate {\r\n  name: string;\r\n  display_name: string;\r\n  description?: string;\r\n  trait_type: TraitType;\r\n  source_config: ComputedTraitSourceConfig;\r\n  output_type?: string;\r\n  default_value?: string;\r\n}\r\n\r\nexport interface CDPComputedTrait {\r\n  id: string;\r\n  name: string;\r\n  display_name: string;\r\n  description?: string;\r\n  trait_type: TraitType;\r\n  source_config: Record<string, unknown>;\r\n  output_type: string;\r\n  default_value?: string;\r\n  is_active: boolean;\r\n  last_computed_at?: string;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface ComputedTraitListResponse {\r\n  traits: CDPComputedTrait[];\r\n  total: number;\r\n}\r\n\r\nexport interface ComputeTraitsResponse {\r\n  profiles_processed: number;\r\n  errors: number;\r\n}\r\n\r\n// RFM Types\r\nexport type RFMSegment =\r\n  | 'champions'\r\n  | 'loyal_customers'\r\n  | 'potential_loyalists'\r\n  | 'new_customers'\r\n  | 'promising'\r\n  | 'need_attention'\r\n  | 'about_to_sleep'\r\n  | 'at_risk'\r\n  | 'cannot_lose'\r\n  | 'hibernating'\r\n  | 'lost'\r\n  | 'other';\r\n\r\nexport interface RFMConfig {\r\n  purchase_event_name?: string;\r\n  revenue_property?: string;\r\n  analysis_window_days?: number;\r\n}\r\n\r\nexport interface RFMScores {\r\n  recency_days: number;\r\n  frequency: number;\r\n  monetary: number;\r\n  recency_score: number;\r\n  frequency_score: number;\r\n  monetary_score: number;\r\n  rfm_score: number;\r\n  rfm_segment: RFMSegment;\r\n  analysis_window_days: number;\r\n  calculated_at: string;\r\n}\r\n\r\nexport interface RFMBatchResponse {\r\n  profiles_processed: number;\r\n  segment_distribution: Record<RFMSegment, number>;\r\n  analysis_window_days: number;\r\n  calculated_at: string;\r\n}\r\n\r\nexport interface RFMSummaryResponse {\r\n  total_profiles: number;\r\n  profiles_with_rfm: number;\r\n  segment_distribution: Record<RFMSegment, number>;\r\n  coverage_pct: number;\r\n}\r\n\r\n// Profile Deletion Types\r\nexport interface ProfileDeletionResponse {\r\n  profile_id: string;\r\n  deleted: boolean;\r\n  events_deleted: number;\r\n  identifiers_deleted: number;\r\n  consents_deleted: number;\r\n  segment_memberships_deleted: number;\r\n  deletion_timestamp: string;\r\n}\r\n\r\n// Funnel/Journey Types\r\nexport type FunnelStatus = 'draft' | 'computing' | 'active' | 'stale' | 'archived';\r\n\r\nexport interface FunnelStepCondition {\r\n  field: string;\r\n  operator: string;\r\n  value: unknown;\r\n}\r\n\r\nexport interface FunnelStep {\r\n  step_name: string;\r\n  event_name: string;\r\n  conditions?: FunnelStepCondition[];\r\n}\r\n\r\nexport interface FunnelCreate {\r\n  name: string;\r\n  description?: string;\r\n  steps: FunnelStep[];\r\n  conversion_window_days?: number;\r\n  step_timeout_hours?: number;\r\n  auto_refresh?: boolean;\r\n  refresh_interval_hours?: number;\r\n  tags?: string[];\r\n}\r\n\r\nexport interface FunnelUpdate {\r\n  name?: string;\r\n  description?: string;\r\n  steps?: FunnelStep[];\r\n  conversion_window_days?: number;\r\n  step_timeout_hours?: number;\r\n  auto_refresh?: boolean;\r\n  refresh_interval_hours?: number;\r\n  tags?: string[];\r\n}\r\n\r\nexport interface FunnelStepMetrics {\r\n  step: number;\r\n  name: string;\r\n  event_name: string;\r\n  count: number;\r\n  conversion_rate: number;\r\n  drop_off_rate: number;\r\n  drop_off_count: number;\r\n}\r\n\r\nexport interface CDPFunnel {\r\n  id: string;\r\n  name: string;\r\n  slug?: string;\r\n  description?: string;\r\n  status: FunnelStatus;\r\n  steps: FunnelStep[];\r\n  conversion_window_days: number;\r\n  step_timeout_hours?: number;\r\n  total_entered: number;\r\n  total_converted: number;\r\n  overall_conversion_rate?: number;\r\n  step_metrics: FunnelStepMetrics[];\r\n  last_computed_at?: string;\r\n  computation_duration_ms?: number;\r\n  auto_refresh: boolean;\r\n  refresh_interval_hours: number;\r\n  next_refresh_at?: string;\r\n  tags: string[];\r\n  created_by_user_id?: number;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface FunnelListResponse {\r\n  funnels: CDPFunnel[];\r\n  total: number;\r\n}\r\n\r\nexport interface FunnelComputeResponse {\r\n  funnel_id: string;\r\n  total_entered: number;\r\n  total_converted: number;\r\n  overall_conversion_rate: number;\r\n  step_metrics: FunnelStepMetrics[];\r\n  computation_duration_ms: number;\r\n}\r\n\r\nexport interface FunnelAnalysisRequest {\r\n  start_date?: string;\r\n  end_date?: string;\r\n}\r\n\r\nexport interface FunnelStepAnalysis {\r\n  step: number;\r\n  name: string;\r\n  event_name: string;\r\n  count: number;\r\n  conversion_rate_from_start: number;\r\n  conversion_rate_from_prev: number;\r\n  drop_off_count: number;\r\n}\r\n\r\nexport interface FunnelAnalysisResponse {\r\n  funnel_id: string;\r\n  funnel_name: string;\r\n  total_entered: number;\r\n  total_converted: number;\r\n  overall_conversion_rate: number;\r\n  step_analysis: FunnelStepAnalysis[];\r\n  avg_conversion_time_seconds?: number;\r\n  analysis_period: {\r\n    start?: string;\r\n    end?: string;\r\n  };\r\n}\r\n\r\nexport interface ProfileFunnelJourney {\r\n  funnel_id: string;\r\n  funnel_name?: string;\r\n  entered_at: string;\r\n  converted_at?: string;\r\n  is_converted: boolean;\r\n  current_step: number;\r\n  completed_steps: number;\r\n  total_steps?: number;\r\n  step_timestamps: Record<string, string>;\r\n  total_duration_seconds?: number;\r\n}\r\n\r\nexport interface ProfileFunnelJourneysResponse {\r\n  profile_id: string;\r\n  journeys: ProfileFunnelJourney[];\r\n}\r\n\r\nexport interface FunnelDropOffResponse {\r\n  funnel_id: string;\r\n  step: number;\r\n  profiles: CDPProfile[];\r\n  total: number;\r\n}\r\n\r\n// Audience Export Types\r\nexport interface AudienceExportParams {\r\n  format?: 'json' | 'csv';\r\n  limit?: number;\r\n  offset?: number;\r\n  segment_id?: string;\r\n  lifecycle_stage?: LifecycleStage;\r\n  rfm_segment?: RFMSegment;\r\n  min_events?: number;\r\n  max_events?: number;\r\n  min_revenue?: number;\r\n  max_revenue?: number;\r\n  first_seen_after?: string;\r\n  first_seen_before?: string;\r\n  last_seen_after?: string;\r\n  last_seen_before?: string;\r\n  has_identifier_type?: IdentifierType;\r\n  include_computed_traits?: boolean;\r\n  include_identifiers?: boolean;\r\n  include_rfm?: boolean;\r\n  include_traits?: boolean;\r\n  include_events?: boolean;\r\n}\r\n\r\nexport interface AudienceExportResponse {\r\n  format: string;\r\n  export_time: string;\r\n  total_matching: number;\r\n  count: number;\r\n  offset: number;\r\n  limit: number;\r\n  filters_applied: Record<string, string | number | null>;\r\n  data: CDPProfile[];\r\n}\r\n\r\n// Profile Search Types\r\nexport interface ProfileSearchParams {\r\n  query?: string;\r\n  limit?: number;\r\n  offset?: number;\r\n  segment_ids?: string[];\r\n  exclude_segment_ids?: string[];\r\n  lifecycle_stages?: LifecycleStage[];\r\n  rfm_segments?: RFMSegment[];\r\n  identifier_types?: IdentifierType[];\r\n  min_events?: number;\r\n  max_events?: number;\r\n  min_revenue?: number;\r\n  max_revenue?: number;\r\n  first_seen_after?: string;\r\n  first_seen_before?: string;\r\n  last_seen_after?: string;\r\n  last_seen_before?: string;\r\n  has_email?: boolean;\r\n  has_phone?: boolean;\r\n  is_customer?: boolean;\r\n  sort_by?: 'last_seen_at' | 'first_seen_at' | 'total_events' | 'total_revenue' | 'created_at';\r\n  sort_order?: 'asc' | 'desc';\r\n  include_identifiers?: boolean;\r\n  include_computed_traits?: boolean;\r\n}\r\n\r\nexport interface ProfileSearchResponse {\r\n  profiles: CDPProfile[];\r\n  total: number;\r\n  offset: number;\r\n  limit: number;\r\n  sort_by: string;\r\n  sort_order: string;\r\n}\r\n\r\n// Event Statistics Types\r\nexport interface EventByName {\r\n  event_name: string;\r\n  count: number;\r\n}\r\n\r\nexport interface DailyVolume {\r\n  date: string;\r\n  count: number;\r\n}\r\n\r\nexport interface EMQDistribution {\r\n  score_range: string;\r\n  count: number;\r\n}\r\n\r\nexport interface EventBySource {\r\n  source_name: string;\r\n  count: number;\r\n}\r\n\r\nexport interface EventStatisticsResponse {\r\n  period_days: number;\r\n  analysis_start: string;\r\n  analysis_end: string;\r\n  total_events: number;\r\n  unique_profiles: number;\r\n  avg_emq_score?: number;\r\n  events_by_name: EventByName[];\r\n  daily_volume: DailyVolume[];\r\n  emq_distribution: EMQDistribution[];\r\n  events_by_source: EventBySource[];\r\n}\r\n\r\nexport interface EventTrend {\r\n  event_name: string;\r\n  current_count: number;\r\n  previous_count: number;\r\n  change_pct: number;\r\n  trend: 'up' | 'down' | 'stable';\r\n}\r\n\r\nexport interface EventTrendsResponse {\r\n  period_days: number;\r\n  current_period: {\r\n    start: string;\r\n    end: string;\r\n    total_events: number;\r\n  };\r\n  previous_period: {\r\n    start: string;\r\n    end: string;\r\n    total_events: number;\r\n  };\r\n  overall_change_pct: number;\r\n  overall_trend: 'up' | 'down' | 'stable';\r\n  event_trends: EventTrend[];\r\n}\r\n\r\nexport interface ProfileStatisticsResponse {\r\n  total_profiles: number;\r\n  lifecycle_distribution: Record<LifecycleStage, number>;\r\n  new_profiles_7d: number;\r\n  active_profiles_30d: number;\r\n  profiles_with_email: number;\r\n  profiles_with_phone: number;\r\n  email_coverage_pct: number;\r\n  phone_coverage_pct: number;\r\n  total_customers: number;\r\n  customer_rate_pct: number;\r\n  revenue: {\r\n    total: number;\r\n    average: number;\r\n    max: number;\r\n  };\r\n  events: {\r\n    total: number;\r\n    average_per_profile: number;\r\n  };\r\n}\r\n\r\n// Export Types\r\nexport type ExportFormat = 'json' | 'csv';\r\n\r\nexport interface ExportProfilesParams {\r\n  format?: ExportFormat;\r\n  limit?: number;\r\n  offset?: number;\r\n}\r\n\r\nexport interface ExportEventsParams {\r\n  format?: ExportFormat;\r\n  limit?: number;\r\n  offset?: number;\r\n  start_date?: string;\r\n  end_date?: string;\r\n  event_name?: string;\r\n}\r\n\r\nexport interface ExportResponse<T> {\r\n  format: string;\r\n  count: number;\r\n  offset: number;\r\n  limit: number;\r\n  data: T[];\r\n  filters?: Record<string, string | null>;\r\n}\r\n\r\n// =============================================================================\r\n// API Functions\r\n// =============================================================================\r\n\r\nexport const cdpApi = {\r\n  // Event Endpoints\r\n  /**\r\n   * Ingest events into CDP\r\n   * @param events Array of events to ingest\r\n   * @param sourceKey Optional source API key for authentication\r\n   */\r\n  ingestEvents: async (events: EventInput[], sourceKey?: string): Promise<EventBatchResponse> => {\r\n    const params = sourceKey ? { source_key: sourceKey } : {};\r\n    const response = await apiClient.post<ApiResponse<EventBatchResponse>>(\r\n      '/cdp/events',\r\n      { events },\r\n      { params }\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Ingest a single event\r\n   * @param event Event to ingest\r\n   * @param sourceKey Optional source API key\r\n   */\r\n  ingestEvent: async (event: EventInput, sourceKey?: string): Promise<EventIngestResult> => {\r\n    const response = await cdpApi.ingestEvents([event], sourceKey);\r\n    return response.results[0];\r\n  },\r\n\r\n  // Profile Endpoints\r\n  /**\r\n   * Get a profile by ID\r\n   * @param profileId UUID of the profile\r\n   */\r\n  getProfile: async (profileId: string): Promise<CDPProfile> => {\r\n    const response = await apiClient.get<ApiResponse<CDPProfile>>(`/cdp/profiles/${profileId}`);\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Lookup a profile by identifier\r\n   * @param identifierType Type of identifier (email, phone, etc.)\r\n   * @param identifierValue Value to look up\r\n   */\r\n  lookupProfile: async (\r\n    identifierType: IdentifierType,\r\n    identifierValue: string\r\n  ): Promise<CDPProfile> => {\r\n    const response = await apiClient.get<ApiResponse<CDPProfile>>('/cdp/profiles', {\r\n      params: {\r\n        identifier_type: identifierType,\r\n        identifier_value: identifierValue,\r\n      },\r\n    });\r\n    return response.data.data;\r\n  },\r\n\r\n  // Source Endpoints\r\n  /**\r\n   * List all data sources\r\n   */\r\n  listSources: async (): Promise<SourceListResponse> => {\r\n    const response = await apiClient.get<ApiResponse<SourceListResponse>>('/cdp/sources');\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Create a new data source\r\n   * @param source Source configuration\r\n   */\r\n  createSource: async (source: SourceCreate): Promise<CDPSource> => {\r\n    const response = await apiClient.post<ApiResponse<CDPSource>>('/cdp/sources', source);\r\n    return response.data.data;\r\n  },\r\n\r\n  // Health Check\r\n  /**\r\n   * Check CDP module health\r\n   */\r\n  health: async (): Promise<CDPHealthResponse> => {\r\n    const response = await apiClient.get<CDPHealthResponse>('/cdp/health');\r\n    return response.data;\r\n  },\r\n\r\n  // Webhook Endpoints\r\n  /**\r\n   * List all webhooks\r\n   */\r\n  listWebhooks: async (): Promise<WebhookListResponse> => {\r\n    const response = await apiClient.get<ApiResponse<WebhookListResponse>>('/cdp/webhooks');\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Create a new webhook\r\n   * @param webhook Webhook configuration\r\n   */\r\n  createWebhook: async (webhook: WebhookCreate): Promise<CDPWebhook> => {\r\n    const response = await apiClient.post<ApiResponse<CDPWebhook>>('/cdp/webhooks', webhook);\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Get a webhook by ID\r\n   * @param webhookId UUID of the webhook\r\n   */\r\n  getWebhook: async (webhookId: string): Promise<CDPWebhook> => {\r\n    const response = await apiClient.get<ApiResponse<CDPWebhook>>(`/cdp/webhooks/${webhookId}`);\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Update a webhook\r\n   * @param webhookId UUID of the webhook\r\n   * @param update Fields to update\r\n   */\r\n  updateWebhook: async (webhookId: string, update: WebhookUpdate): Promise<CDPWebhook> => {\r\n    const response = await apiClient.patch<ApiResponse<CDPWebhook>>(\r\n      `/cdp/webhooks/${webhookId}`,\r\n      update\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Delete a webhook\r\n   * @param webhookId UUID of the webhook\r\n   */\r\n  deleteWebhook: async (webhookId: string): Promise<void> => {\r\n    await apiClient.delete(`/cdp/webhooks/${webhookId}`);\r\n  },\r\n\r\n  /**\r\n   * Test a webhook\r\n   * @param webhookId UUID of the webhook\r\n   */\r\n  testWebhook: async (webhookId: string): Promise<WebhookTestResult> => {\r\n    const response = await apiClient.post<ApiResponse<WebhookTestResult>>(\r\n      `/cdp/webhooks/${webhookId}/test`\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Rotate webhook secret\r\n   * @param webhookId UUID of the webhook\r\n   */\r\n  rotateWebhookSecret: async (webhookId: string): Promise<CDPWebhook> => {\r\n    const response = await apiClient.post<ApiResponse<CDPWebhook>>(\r\n      `/cdp/webhooks/${webhookId}/rotate-secret`\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  // Anomaly Detection Endpoints\r\n  /**\r\n   * Detect event volume anomalies\r\n   * @param params Optional parameters for analysis\r\n   */\r\n  detectEventAnomalies: async (\r\n    params?: AnomalyDetectionParams\r\n  ): Promise<AnomalyDetectionResponse> => {\r\n    const response = await apiClient.get<AnomalyDetectionResponse>('/cdp/anomalies/events', {\r\n      params,\r\n    });\r\n    return response.data;\r\n  },\r\n\r\n  /**\r\n   * Get anomaly detection summary\r\n   */\r\n  getAnomalySummary: async (): Promise<AnomalySummaryResponse> => {\r\n    const response = await apiClient.get<AnomalySummaryResponse>('/cdp/anomalies/summary');\r\n    return response.data;\r\n  },\r\n\r\n  // Export Endpoints\r\n  /**\r\n   * Export profiles in JSON or CSV format\r\n   * @param params Export parameters (format, limit, offset)\r\n   */\r\n  exportProfiles: async (\r\n    params?: ExportProfilesParams\r\n  ): Promise<ExportResponse<CDPProfile> | Blob> => {\r\n    const format = params?.format || 'json';\r\n\r\n    if (format === 'csv') {\r\n      const response = await apiClient.get('/cdp/export/profiles', {\r\n        params: { ...params, format: 'csv' },\r\n        responseType: 'blob',\r\n      });\r\n      return response.data;\r\n    }\r\n\r\n    const response = await apiClient.get<ExportResponse<CDPProfile>>('/cdp/export/profiles', {\r\n      params,\r\n    });\r\n    return response.data;\r\n  },\r\n\r\n  /**\r\n   * Export events in JSON or CSV format\r\n   * @param params Export parameters (format, limit, offset, date filters)\r\n   */\r\n  exportEvents: async (params?: ExportEventsParams): Promise<ExportResponse<CDPEvent> | Blob> => {\r\n    const format = params?.format || 'json';\r\n\r\n    if (format === 'csv') {\r\n      const response = await apiClient.get('/cdp/export/events', {\r\n        params: { ...params, format: 'csv' },\r\n        responseType: 'blob',\r\n      });\r\n      return response.data;\r\n    }\r\n\r\n    const response = await apiClient.get<ExportResponse<CDPEvent>>('/cdp/export/events', {\r\n      params,\r\n    });\r\n    return response.data;\r\n  },\r\n\r\n  // Identity Graph Endpoints\r\n  /**\r\n   * Get identity graph for a profile\r\n   * @param profileId UUID of the profile\r\n   */\r\n  getIdentityGraph: async (profileId: string): Promise<IdentityGraphResponse> => {\r\n    const response = await apiClient.get<ApiResponse<IdentityGraphResponse>>(\r\n      `/cdp/profiles/${profileId}/identity-graph`\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Get canonical identity for a profile\r\n   * @param profileId UUID of the profile\r\n   */\r\n  getCanonicalIdentity: async (profileId: string): Promise<CanonicalIdentity> => {\r\n    const response = await apiClient.get<ApiResponse<CanonicalIdentity>>(\r\n      `/cdp/profiles/${profileId}/canonical-identity`\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Get merge history for a profile\r\n   * @param profileId UUID of the profile\r\n   */\r\n  getProfileMergeHistory: async (profileId: string): Promise<ProfileMergeHistoryResponse> => {\r\n    const response = await apiClient.get<ApiResponse<ProfileMergeHistoryResponse>>(\r\n      `/cdp/profiles/${profileId}/merge-history`\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Manually merge two profiles\r\n   * @param request Merge request with source and target profile IDs\r\n   */\r\n  mergeProfiles: async (request: ProfileMergeRequest): Promise<ProfileMerge> => {\r\n    const response = await apiClient.post<ApiResponse<ProfileMerge>>(\r\n      '/cdp/profiles/merge',\r\n      request\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * List all profile merges for the tenant\r\n   * @param params Pagination parameters\r\n   */\r\n  listMergeHistory: async (params?: {\r\n    limit?: number;\r\n    offset?: number;\r\n  }): Promise<ProfileMergeHistoryResponse> => {\r\n    const response = await apiClient.get<ApiResponse<ProfileMergeHistoryResponse>>(\r\n      '/cdp/merge-history',\r\n      { params }\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * List identity links for the tenant\r\n   * @param params Filter and pagination parameters\r\n   */\r\n  listIdentityLinks: async (params?: {\r\n    limit?: number;\r\n    offset?: number;\r\n    link_type?: IdentityLinkType;\r\n  }): Promise<IdentityLinksResponse> => {\r\n    const response = await apiClient.get<IdentityLinksResponse>('/cdp/identity-links', { params });\r\n    return response.data;\r\n  },\r\n\r\n  // Segment Endpoints\r\n  /**\r\n   * Create a new segment\r\n   */\r\n  createSegment: async (segment: SegmentCreate): Promise<CDPSegment> => {\r\n    const response = await apiClient.post<ApiResponse<CDPSegment>>('/cdp/segments', segment);\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * List all segments\r\n   */\r\n  listSegments: async (params?: {\r\n    status?: SegmentStatus;\r\n    segment_type?: SegmentType;\r\n    limit?: number;\r\n    offset?: number;\r\n  }): Promise<SegmentListResponse> => {\r\n    const response = await apiClient.get<ApiResponse<SegmentListResponse>>('/cdp/segments', {\r\n      params,\r\n    });\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Get a segment by ID\r\n   */\r\n  getSegment: async (segmentId: string): Promise<CDPSegment> => {\r\n    const response = await apiClient.get<ApiResponse<CDPSegment>>(`/cdp/segments/${segmentId}`);\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Update a segment\r\n   */\r\n  updateSegment: async (segmentId: string, update: SegmentUpdate): Promise<CDPSegment> => {\r\n    const response = await apiClient.patch<ApiResponse<CDPSegment>>(\r\n      `/cdp/segments/${segmentId}`,\r\n      update\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Delete a segment\r\n   */\r\n  deleteSegment: async (segmentId: string): Promise<void> => {\r\n    await apiClient.delete(`/cdp/segments/${segmentId}`);\r\n  },\r\n\r\n  /**\r\n   * Compute segment membership\r\n   */\r\n  computeSegment: async (segmentId: string): Promise<CDPSegment> => {\r\n    const response = await apiClient.post<ApiResponse<CDPSegment>>(\r\n      `/cdp/segments/${segmentId}/compute`\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Preview segment membership\r\n   */\r\n  previewSegment: async (request: SegmentPreviewRequest): Promise<SegmentPreviewResponse> => {\r\n    const response = await apiClient.post<ApiResponse<SegmentPreviewResponse>>(\r\n      '/cdp/segments/preview',\r\n      request\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Get profiles in a segment\r\n   */\r\n  getSegmentProfiles: async (\r\n    segmentId: string,\r\n    params?: {\r\n      limit?: number;\r\n      offset?: number;\r\n    }\r\n  ): Promise<SegmentProfilesResponse> => {\r\n    const response = await apiClient.get<ApiResponse<SegmentProfilesResponse>>(\r\n      `/cdp/segments/${segmentId}/profiles`,\r\n      { params }\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Get segments a profile belongs to\r\n   */\r\n  getProfileSegments: async (profileId: string): Promise<ProfileSegmentsResponse> => {\r\n    const response = await apiClient.get<ApiResponse<ProfileSegmentsResponse>>(\r\n      `/cdp/profiles/${profileId}/segments`\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Delete a profile (GDPR)\r\n   */\r\n  deleteProfile: async (\r\n    profileId: string,\r\n    params?: {\r\n      delete_events?: boolean;\r\n      reason?: string;\r\n    }\r\n  ): Promise<ProfileDeletionResponse> => {\r\n    const response = await apiClient.delete<ApiResponse<ProfileDeletionResponse>>(\r\n      `/cdp/profiles/${profileId}`,\r\n      { params }\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  // Computed Traits Endpoints\r\n  /**\r\n   * Create a computed trait\r\n   */\r\n  createTrait: async (trait: ComputedTraitCreate): Promise<CDPComputedTrait> => {\r\n    const response = await apiClient.post<ApiResponse<CDPComputedTrait>>('/cdp/traits', trait);\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * List computed traits\r\n   */\r\n  listTraits: async (params?: {\r\n    active_only?: boolean;\r\n    limit?: number;\r\n    offset?: number;\r\n  }): Promise<ComputedTraitListResponse> => {\r\n    const response = await apiClient.get<ApiResponse<ComputedTraitListResponse>>('/cdp/traits', {\r\n      params,\r\n    });\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Get a computed trait by ID\r\n   */\r\n  getTrait: async (traitId: string): Promise<CDPComputedTrait> => {\r\n    const response = await apiClient.get<ApiResponse<CDPComputedTrait>>(`/cdp/traits/${traitId}`);\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Delete a computed trait\r\n   */\r\n  deleteTrait: async (traitId: string): Promise<void> => {\r\n    await apiClient.delete(`/cdp/traits/${traitId}`);\r\n  },\r\n\r\n  /**\r\n   * Compute all traits for all profiles\r\n   */\r\n  computeAllTraits: async (): Promise<ComputeTraitsResponse> => {\r\n    const response =\r\n      await apiClient.post<ApiResponse<ComputeTraitsResponse>>('/cdp/traits/compute');\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Compute traits for a specific profile\r\n   */\r\n  computeProfileTraits: async (\r\n    profileId: string\r\n  ): Promise<{ profile_id: string; computed_traits: Record<string, unknown> }> => {\r\n    const response = await apiClient.post<\r\n      ApiResponse<{ profile_id: string; computed_traits: Record<string, unknown> }>\r\n    >(`/cdp/profiles/${profileId}/compute-traits`);\r\n    return response.data.data;\r\n  },\r\n\r\n  // RFM Endpoints\r\n  /**\r\n   * Get RFM scores for a profile\r\n   */\r\n  getProfileRFM: async (profileId: string, params?: RFMConfig): Promise<RFMScores> => {\r\n    const response = await apiClient.get<ApiResponse<RFMScores>>(`/cdp/profiles/${profileId}/rfm`, {\r\n      params,\r\n    });\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Compute RFM for all profiles\r\n   */\r\n  computeRFMBatch: async (config?: RFMConfig): Promise<RFMBatchResponse> => {\r\n    const response = await apiClient.post<ApiResponse<RFMBatchResponse>>(\r\n      '/cdp/rfm/compute',\r\n      config\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Get RFM summary\r\n   */\r\n  getRFMSummary: async (): Promise<RFMSummaryResponse> => {\r\n    const response = await apiClient.get<ApiResponse<RFMSummaryResponse>>('/cdp/rfm/summary');\r\n    return response.data.data;\r\n  },\r\n\r\n  // Funnel/Journey Endpoints\r\n  /**\r\n   * Create a new funnel\r\n   */\r\n  createFunnel: async (funnel: FunnelCreate): Promise<CDPFunnel> => {\r\n    const response = await apiClient.post<ApiResponse<CDPFunnel>>('/cdp/funnels', funnel);\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * List all funnels\r\n   */\r\n  listFunnels: async (params?: {\r\n    status?: FunnelStatus;\r\n    limit?: number;\r\n    offset?: number;\r\n  }): Promise<FunnelListResponse> => {\r\n    const response = await apiClient.get<ApiResponse<FunnelListResponse>>('/cdp/funnels', {\r\n      params,\r\n    });\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Get a funnel by ID\r\n   */\r\n  getFunnel: async (funnelId: string): Promise<CDPFunnel> => {\r\n    const response = await apiClient.get<ApiResponse<CDPFunnel>>(`/cdp/funnels/${funnelId}`);\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Update a funnel\r\n   */\r\n  updateFunnel: async (funnelId: string, update: FunnelUpdate): Promise<CDPFunnel> => {\r\n    const response = await apiClient.patch<ApiResponse<CDPFunnel>>(\r\n      `/cdp/funnels/${funnelId}`,\r\n      update\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Delete a funnel\r\n   */\r\n  deleteFunnel: async (funnelId: string): Promise<void> => {\r\n    await apiClient.delete(`/cdp/funnels/${funnelId}`);\r\n  },\r\n\r\n  /**\r\n   * Compute funnel metrics\r\n   */\r\n  computeFunnel: async (funnelId: string): Promise<FunnelComputeResponse> => {\r\n    const response = await apiClient.post<ApiResponse<FunnelComputeResponse>>(\r\n      `/cdp/funnels/${funnelId}/compute`\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Analyze funnel with date filtering\r\n   */\r\n  analyzeFunnel: async (\r\n    funnelId: string,\r\n    params?: FunnelAnalysisRequest\r\n  ): Promise<FunnelAnalysisResponse> => {\r\n    const response = await apiClient.post<ApiResponse<FunnelAnalysisResponse>>(\r\n      `/cdp/funnels/${funnelId}/analyze`,\r\n      params\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Get profiles that dropped off at a specific step\r\n   */\r\n  getFunnelDropOffs: async (\r\n    funnelId: string,\r\n    step: number,\r\n    params?: { limit?: number; offset?: number }\r\n  ): Promise<FunnelDropOffResponse> => {\r\n    const response = await apiClient.get<ApiResponse<FunnelDropOffResponse>>(\r\n      `/cdp/funnels/${funnelId}/drop-offs/${step}`,\r\n      { params }\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  /**\r\n   * Get a profile's funnel journeys\r\n   */\r\n  getProfileFunnelJourneys: async (\r\n    profileId: string,\r\n    funnelId?: string\r\n  ): Promise<ProfileFunnelJourneysResponse> => {\r\n    const response = await apiClient.get<ApiResponse<ProfileFunnelJourneysResponse>>(\r\n      `/cdp/profiles/${profileId}/funnels`,\r\n      { params: funnelId ? { funnel_id: funnelId } : undefined }\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  // Analytics Endpoints\r\n  /**\r\n   * Get event statistics\r\n   * @param period_days Analysis period in days\r\n   */\r\n  getEventStatistics: async (period_days?: number): Promise<EventStatisticsResponse> => {\r\n    const response = await apiClient.get<EventStatisticsResponse>('/cdp/events/statistics', {\r\n      params: period_days ? { period_days } : undefined,\r\n    });\r\n    return response.data;\r\n  },\r\n\r\n  /**\r\n   * Get event trends\r\n   * @param period_days Period in days for comparison\r\n   */\r\n  getEventTrends: async (period_days?: number): Promise<EventTrendsResponse> => {\r\n    const response = await apiClient.get<EventTrendsResponse>('/cdp/events/trends', {\r\n      params: period_days ? { period_days } : undefined,\r\n    });\r\n    return response.data;\r\n  },\r\n\r\n  /**\r\n   * Get profile statistics\r\n   */\r\n  getProfileStatistics: async (): Promise<ProfileStatisticsResponse> => {\r\n    const response = await apiClient.get<ProfileStatisticsResponse>('/cdp/profiles/statistics');\r\n    return response.data;\r\n  },\r\n\r\n  // Profile Search Endpoints\r\n  /**\r\n   * Search profiles with advanced filters\r\n   * @param params Search parameters including filters and sorting\r\n   */\r\n  searchProfiles: async (params?: ProfileSearchParams): Promise<ProfileSearchResponse> => {\r\n    const response = await apiClient.post<ProfileSearchResponse>('/cdp/profiles/search', null, {\r\n      params,\r\n    });\r\n    return response.data;\r\n  },\r\n\r\n  // Audience Export Endpoints\r\n  /**\r\n   * Export audience with advanced filters\r\n   * @param params Export parameters including filters and format\r\n   */\r\n  exportAudience: async (params?: AudienceExportParams): Promise<AudienceExportResponse | Blob> => {\r\n    const format = params?.format || 'json';\r\n\r\n    if (format === 'csv') {\r\n      const response = await apiClient.post('/cdp/audiences/export', null, {\r\n        params: { ...params, format: 'csv' },\r\n        responseType: 'blob',\r\n      });\r\n      return response.data;\r\n    }\r\n\r\n    const response = await apiClient.post<AudienceExportResponse>('/cdp/audiences/export', null, {\r\n      params,\r\n    });\r\n    return response.data;\r\n  },\r\n};\r\n\r\n// =============================================================================\r\n// React Query Hooks\r\n// =============================================================================\r\n\r\n// Query Keys\r\nexport const cdpQueryKeys = {\r\n  all: ['cdp'] as const,\r\n  profiles: () => [...cdpQueryKeys.all, 'profiles'] as const,\r\n  profile: (id: string) => [...cdpQueryKeys.profiles(), id] as const,\r\n  profileByIdentifier: (type: IdentifierType, value: string) =>\r\n    [...cdpQueryKeys.profiles(), 'lookup', type, value] as const,\r\n  sources: () => [...cdpQueryKeys.all, 'sources'] as const,\r\n  health: () => [...cdpQueryKeys.all, 'health'] as const,\r\n  webhooks: () => [...cdpQueryKeys.all, 'webhooks'] as const,\r\n  webhook: (id: string) => [...cdpQueryKeys.webhooks(), id] as const,\r\n  anomalies: () => [...cdpQueryKeys.all, 'anomalies'] as const,\r\n  anomalySummary: () => [...cdpQueryKeys.anomalies(), 'summary'] as const,\r\n  identityGraph: (profileId: string) =>\r\n    [...cdpQueryKeys.profiles(), profileId, 'identity-graph'] as const,\r\n  canonicalIdentity: (profileId: string) =>\r\n    [...cdpQueryKeys.profiles(), profileId, 'canonical'] as const,\r\n  profileMergeHistory: (profileId: string) =>\r\n    [...cdpQueryKeys.profiles(), profileId, 'merge-history'] as const,\r\n  mergeHistory: () => [...cdpQueryKeys.all, 'merge-history'] as const,\r\n  identityLinks: () => [...cdpQueryKeys.all, 'identity-links'] as const,\r\n  segments: () => [...cdpQueryKeys.all, 'segments'] as const,\r\n  segment: (id: string) => [...cdpQueryKeys.segments(), id] as const,\r\n  segmentProfiles: (id: string) => [...cdpQueryKeys.segments(), id, 'profiles'] as const,\r\n  profileSegments: (profileId: string) =>\r\n    [...cdpQueryKeys.profiles(), profileId, 'segments'] as const,\r\n  traits: () => [...cdpQueryKeys.all, 'traits'] as const,\r\n  trait: (id: string) => [...cdpQueryKeys.traits(), id] as const,\r\n  profileRFM: (profileId: string) => [...cdpQueryKeys.profiles(), profileId, 'rfm'] as const,\r\n  rfmSummary: () => [...cdpQueryKeys.all, 'rfm-summary'] as const,\r\n  funnels: () => [...cdpQueryKeys.all, 'funnels'] as const,\r\n  funnel: (id: string) => [...cdpQueryKeys.funnels(), id] as const,\r\n  funnelDropOffs: (id: string, step: number) =>\r\n    [...cdpQueryKeys.funnels(), id, 'drop-offs', step] as const,\r\n  profileFunnels: (profileId: string) =>\r\n    [...cdpQueryKeys.profiles(), profileId, 'funnels'] as const,\r\n  profileSearch: () => [...cdpQueryKeys.profiles(), 'search'] as const,\r\n  // Analytics\r\n  eventStatistics: (periodDays?: number) =>\r\n    [...cdpQueryKeys.all, 'event-statistics', periodDays] as const,\r\n  eventTrends: (periodDays?: number) => [...cdpQueryKeys.all, 'event-trends', periodDays] as const,\r\n  profileStatistics: () => [...cdpQueryKeys.all, 'profile-statistics'] as const,\r\n};\r\n\r\n/**\r\n * Hook to get a profile by ID\r\n */\r\nexport function useCDPProfile(profileId: string, options?: { enabled?: boolean }) {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.profile(profileId),\r\n    queryFn: () => cdpApi.getProfile(profileId),\r\n    staleTime: 30 * 1000, // 30 seconds\r\n    enabled: options?.enabled ?? !!profileId,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to lookup a profile by identifier\r\n */\r\nexport function useCDPProfileLookup(\r\n  identifierType: IdentifierType,\r\n  identifierValue: string,\r\n  options?: { enabled?: boolean }\r\n) {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.profileByIdentifier(identifierType, identifierValue),\r\n    queryFn: () => cdpApi.lookupProfile(identifierType, identifierValue),\r\n    staleTime: 30 * 1000,\r\n    enabled: options?.enabled ?? (!!identifierType && !!identifierValue),\r\n    retry: false, // Don't retry 404s\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to list all data sources\r\n */\r\nexport function useCDPSources() {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.sources(),\r\n    queryFn: () => cdpApi.listSources(),\r\n    staleTime: 60 * 1000, // 1 minute\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to ingest events\r\n */\r\nexport function useIngestEvents(options?: { sourceKey?: string }) {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: (events: EventInput[]) => cdpApi.ingestEvents(events, options?.sourceKey),\r\n    onSuccess: () => {\r\n      // Invalidate profiles as they may have been updated\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.profiles() });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to ingest a single event\r\n */\r\nexport function useIngestEvent(options?: { sourceKey?: string }) {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: (event: EventInput) => cdpApi.ingestEvent(event, options?.sourceKey),\r\n    onSuccess: () => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.profiles() });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to create a new data source\r\n */\r\nexport function useCreateSource() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: (source: SourceCreate) => cdpApi.createSource(source),\r\n    onSuccess: () => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.sources() });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to check CDP health\r\n */\r\nexport function useCDPHealth() {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.health(),\r\n    queryFn: () => cdpApi.health(),\r\n    staleTime: 60 * 1000,\r\n    refetchInterval: 5 * 60 * 1000, // Every 5 minutes\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to list all webhooks\r\n */\r\nexport function useCDPWebhooks() {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.webhooks(),\r\n    queryFn: () => cdpApi.listWebhooks(),\r\n    staleTime: 60 * 1000, // 1 minute\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to get a webhook by ID\r\n */\r\nexport function useCDPWebhook(webhookId: string, options?: { enabled?: boolean }) {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.webhook(webhookId),\r\n    queryFn: () => cdpApi.getWebhook(webhookId),\r\n    staleTime: 30 * 1000,\r\n    enabled: options?.enabled ?? !!webhookId,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to create a new webhook\r\n */\r\nexport function useCreateWebhook() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: (webhook: WebhookCreate) => cdpApi.createWebhook(webhook),\r\n    onSuccess: () => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.webhooks() });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to update a webhook\r\n */\r\nexport function useUpdateWebhook() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: ({ webhookId, update }: { webhookId: string; update: WebhookUpdate }) =>\r\n      cdpApi.updateWebhook(webhookId, update),\r\n    onSuccess: (_, { webhookId }) => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.webhooks() });\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.webhook(webhookId) });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to delete a webhook\r\n */\r\nexport function useDeleteWebhook() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: (webhookId: string) => cdpApi.deleteWebhook(webhookId),\r\n    onSuccess: () => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.webhooks() });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to test a webhook\r\n */\r\nexport function useTestWebhook() {\r\n  return useMutation({\r\n    mutationFn: (webhookId: string) => cdpApi.testWebhook(webhookId),\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to rotate webhook secret\r\n */\r\nexport function useRotateWebhookSecret() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: (webhookId: string) => cdpApi.rotateWebhookSecret(webhookId),\r\n    onSuccess: (_, webhookId) => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.webhook(webhookId) });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to detect event volume anomalies\r\n */\r\nexport function useEventAnomalies(params?: AnomalyDetectionParams) {\r\n  return useQuery({\r\n    queryKey: [...cdpQueryKeys.anomalies(), params],\r\n    queryFn: () => cdpApi.detectEventAnomalies(params),\r\n    staleTime: 5 * 60 * 1000, // 5 minutes\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to get anomaly detection summary\r\n */\r\nexport function useAnomalySummary() {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.anomalySummary(),\r\n    queryFn: () => cdpApi.getAnomalySummary(),\r\n    staleTime: 60 * 1000, // 1 minute\r\n    refetchInterval: 5 * 60 * 1000, // Every 5 minutes\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to get identity graph for a profile\r\n */\r\nexport function useIdentityGraph(profileId: string, options?: { enabled?: boolean }) {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.identityGraph(profileId),\r\n    queryFn: () => cdpApi.getIdentityGraph(profileId),\r\n    staleTime: 30 * 1000, // 30 seconds\r\n    enabled: options?.enabled ?? !!profileId,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to get canonical identity for a profile\r\n */\r\nexport function useCanonicalIdentity(profileId: string, options?: { enabled?: boolean }) {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.canonicalIdentity(profileId),\r\n    queryFn: () => cdpApi.getCanonicalIdentity(profileId),\r\n    staleTime: 30 * 1000,\r\n    enabled: options?.enabled ?? !!profileId,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to get merge history for a profile\r\n */\r\nexport function useProfileMergeHistory(profileId: string, options?: { enabled?: boolean }) {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.profileMergeHistory(profileId),\r\n    queryFn: () => cdpApi.getProfileMergeHistory(profileId),\r\n    staleTime: 60 * 1000,\r\n    enabled: options?.enabled ?? !!profileId,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to list all profile merges\r\n */\r\nexport function useMergeHistory(params?: { limit?: number; offset?: number }) {\r\n  return useQuery({\r\n    queryKey: [...cdpQueryKeys.mergeHistory(), params],\r\n    queryFn: () => cdpApi.listMergeHistory(params),\r\n    staleTime: 60 * 1000,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to list identity links\r\n */\r\nexport function useIdentityLinks(params?: {\r\n  limit?: number;\r\n  offset?: number;\r\n  link_type?: IdentityLinkType;\r\n}) {\r\n  return useQuery({\r\n    queryKey: [...cdpQueryKeys.identityLinks(), params],\r\n    queryFn: () => cdpApi.listIdentityLinks(params),\r\n    staleTime: 60 * 1000,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to merge profiles\r\n */\r\nexport function useMergeProfiles() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: (request: ProfileMergeRequest) => cdpApi.mergeProfiles(request),\r\n    onSuccess: (_, request) => {\r\n      // Invalidate both profiles and merge history\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.profile(request.source_profile_id) });\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.profile(request.target_profile_id) });\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.mergeHistory() });\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.identityLinks() });\r\n    },\r\n  });\r\n}\r\n\r\n// Segment Hooks\r\n\r\n/**\r\n * Hook to list segments\r\n */\r\nexport function useSegments(params?: {\r\n  status?: SegmentStatus;\r\n  segment_type?: SegmentType;\r\n  limit?: number;\r\n  offset?: number;\r\n}) {\r\n  return useQuery({\r\n    queryKey: [...cdpQueryKeys.segments(), params],\r\n    queryFn: () => cdpApi.listSegments(params),\r\n    staleTime: 60 * 1000,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to get a segment by ID\r\n */\r\nexport function useSegment(segmentId: string, options?: { enabled?: boolean }) {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.segment(segmentId),\r\n    queryFn: () => cdpApi.getSegment(segmentId),\r\n    staleTime: 30 * 1000,\r\n    enabled: options?.enabled ?? !!segmentId,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to create a segment\r\n */\r\nexport function useCreateSegment() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: (segment: SegmentCreate) => cdpApi.createSegment(segment),\r\n    onSuccess: () => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.segments() });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to update a segment\r\n */\r\nexport function useUpdateSegment() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: ({ segmentId, update }: { segmentId: string; update: SegmentUpdate }) =>\r\n      cdpApi.updateSegment(segmentId, update),\r\n    onSuccess: (_, { segmentId }) => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.segments() });\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.segment(segmentId) });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to delete a segment\r\n */\r\nexport function useDeleteSegment() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: (segmentId: string) => cdpApi.deleteSegment(segmentId),\r\n    onSuccess: () => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.segments() });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to compute segment membership\r\n */\r\nexport function useComputeSegment() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: (segmentId: string) => cdpApi.computeSegment(segmentId),\r\n    onSuccess: (_, segmentId) => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.segment(segmentId) });\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.segmentProfiles(segmentId) });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to preview segment membership\r\n */\r\nexport function usePreviewSegment() {\r\n  return useMutation({\r\n    mutationFn: (request: SegmentPreviewRequest) => cdpApi.previewSegment(request),\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to get profiles in a segment\r\n */\r\nexport function useSegmentProfiles(\r\n  segmentId: string,\r\n  params?: { limit?: number; offset?: number },\r\n  options?: { enabled?: boolean }\r\n) {\r\n  return useQuery({\r\n    queryKey: [...cdpQueryKeys.segmentProfiles(segmentId), params],\r\n    queryFn: () => cdpApi.getSegmentProfiles(segmentId, params),\r\n    staleTime: 60 * 1000,\r\n    enabled: options?.enabled ?? !!segmentId,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to get segments a profile belongs to\r\n */\r\nexport function useProfileSegments(profileId: string, options?: { enabled?: boolean }) {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.profileSegments(profileId),\r\n    queryFn: () => cdpApi.getProfileSegments(profileId),\r\n    staleTime: 60 * 1000,\r\n    enabled: options?.enabled ?? !!profileId,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to delete a profile (GDPR)\r\n */\r\nexport function useDeleteProfile() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: ({\r\n      profileId,\r\n      params,\r\n    }: {\r\n      profileId: string;\r\n      params?: { delete_events?: boolean; reason?: string };\r\n    }) => cdpApi.deleteProfile(profileId, params),\r\n    onSuccess: (_, { profileId }) => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.profile(profileId) });\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.profiles() });\r\n    },\r\n  });\r\n}\r\n\r\n// Computed Traits Hooks\r\n\r\n/**\r\n * Hook to list computed traits\r\n */\r\nexport function useComputedTraits(params?: {\r\n  active_only?: boolean;\r\n  limit?: number;\r\n  offset?: number;\r\n}) {\r\n  return useQuery({\r\n    queryKey: [...cdpQueryKeys.traits(), params],\r\n    queryFn: () => cdpApi.listTraits(params),\r\n    staleTime: 60 * 1000,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to get a computed trait by ID\r\n */\r\nexport function useComputedTrait(traitId: string, options?: { enabled?: boolean }) {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.trait(traitId),\r\n    queryFn: () => cdpApi.getTrait(traitId),\r\n    staleTime: 30 * 1000,\r\n    enabled: options?.enabled ?? !!traitId,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to create a computed trait\r\n */\r\nexport function useCreateComputedTrait() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: (trait: ComputedTraitCreate) => cdpApi.createTrait(trait),\r\n    onSuccess: () => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.traits() });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to delete a computed trait\r\n */\r\nexport function useDeleteComputedTrait() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: (traitId: string) => cdpApi.deleteTrait(traitId),\r\n    onSuccess: () => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.traits() });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to compute all traits\r\n */\r\nexport function useComputeAllTraits() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: () => cdpApi.computeAllTraits(),\r\n    onSuccess: () => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.profiles() });\r\n    },\r\n  });\r\n}\r\n\r\n// RFM Hooks\r\n\r\n/**\r\n * Hook to get RFM scores for a profile\r\n */\r\nexport function useProfileRFM(\r\n  profileId: string,\r\n  params?: RFMConfig,\r\n  options?: { enabled?: boolean }\r\n) {\r\n  return useQuery({\r\n    queryKey: [...cdpQueryKeys.profileRFM(profileId), params],\r\n    queryFn: () => cdpApi.getProfileRFM(profileId, params),\r\n    staleTime: 5 * 60 * 1000, // 5 minutes\r\n    enabled: options?.enabled ?? !!profileId,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to compute RFM for all profiles\r\n */\r\nexport function useComputeRFMBatch() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: (config?: RFMConfig) => cdpApi.computeRFMBatch(config),\r\n    onSuccess: () => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.profiles() });\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.rfmSummary() });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to get RFM summary\r\n */\r\nexport function useRFMSummary() {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.rfmSummary(),\r\n    queryFn: () => cdpApi.getRFMSummary(),\r\n    staleTime: 5 * 60 * 1000, // 5 minutes\r\n  });\r\n}\r\n\r\n// Funnel Hooks\r\n\r\n/**\r\n * Hook to list funnels\r\n */\r\nexport function useFunnels(params?: { status?: FunnelStatus; limit?: number; offset?: number }) {\r\n  return useQuery({\r\n    queryKey: [...cdpQueryKeys.funnels(), params],\r\n    queryFn: () => cdpApi.listFunnels(params),\r\n    staleTime: 60 * 1000,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to get a funnel by ID\r\n */\r\nexport function useFunnel(funnelId: string, options?: { enabled?: boolean }) {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.funnel(funnelId),\r\n    queryFn: () => cdpApi.getFunnel(funnelId),\r\n    staleTime: 30 * 1000,\r\n    enabled: options?.enabled ?? !!funnelId,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to create a funnel\r\n */\r\nexport function useCreateFunnel() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: (funnel: FunnelCreate) => cdpApi.createFunnel(funnel),\r\n    onSuccess: () => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.funnels() });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to update a funnel\r\n */\r\nexport function useUpdateFunnel() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: ({ funnelId, update }: { funnelId: string; update: FunnelUpdate }) =>\r\n      cdpApi.updateFunnel(funnelId, update),\r\n    onSuccess: (_, { funnelId }) => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.funnels() });\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.funnel(funnelId) });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to delete a funnel\r\n */\r\nexport function useDeleteFunnel() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: (funnelId: string) => cdpApi.deleteFunnel(funnelId),\r\n    onSuccess: () => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.funnels() });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to compute funnel metrics\r\n */\r\nexport function useComputeFunnel() {\r\n  const queryClient = useQueryClient();\r\n\r\n  return useMutation({\r\n    mutationFn: (funnelId: string) => cdpApi.computeFunnel(funnelId),\r\n    onSuccess: (_, funnelId) => {\r\n      queryClient.invalidateQueries({ queryKey: cdpQueryKeys.funnel(funnelId) });\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to analyze funnel with date filtering\r\n */\r\nexport function useAnalyzeFunnel() {\r\n  return useMutation({\r\n    mutationFn: ({ funnelId, params }: { funnelId: string; params?: FunnelAnalysisRequest }) =>\r\n      cdpApi.analyzeFunnel(funnelId, params),\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to get profiles that dropped off at a specific step\r\n */\r\nexport function useFunnelDropOffs(\r\n  funnelId: string,\r\n  step: number,\r\n  params?: { limit?: number; offset?: number },\r\n  options?: { enabled?: boolean }\r\n) {\r\n  return useQuery({\r\n    queryKey: [...cdpQueryKeys.funnelDropOffs(funnelId, step), params],\r\n    queryFn: () => cdpApi.getFunnelDropOffs(funnelId, step, params),\r\n    staleTime: 60 * 1000,\r\n    enabled: options?.enabled ?? (!!funnelId && step > 0),\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to get a profile's funnel journeys\r\n */\r\nexport function useProfileFunnelJourneys(\r\n  profileId: string,\r\n  funnelId?: string,\r\n  options?: { enabled?: boolean }\r\n) {\r\n  return useQuery({\r\n    queryKey: [...cdpQueryKeys.profileFunnels(profileId), funnelId],\r\n    queryFn: () => cdpApi.getProfileFunnelJourneys(profileId, funnelId),\r\n    staleTime: 60 * 1000,\r\n    enabled: options?.enabled ?? !!profileId,\r\n  });\r\n}\r\n\r\n// Profile Search Hook\r\n\r\n/**\r\n * Hook to search profiles with advanced filters\r\n */\r\nexport function useSearchProfiles(params?: ProfileSearchParams, options?: { enabled?: boolean }) {\r\n  return useQuery({\r\n    queryKey: [...cdpQueryKeys.profileSearch(), params],\r\n    queryFn: () => cdpApi.searchProfiles(params),\r\n    staleTime: 30 * 1000,\r\n    enabled: options?.enabled ?? true,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to search profiles (mutation for on-demand searches)\r\n */\r\nexport function useSearchProfilesMutation() {\r\n  return useMutation({\r\n    mutationFn: (params?: ProfileSearchParams) => cdpApi.searchProfiles(params),\r\n  });\r\n}\r\n\r\n// Audience Export Hook\r\n\r\n/**\r\n * Hook to export audience with advanced filters\r\n */\r\nexport function useExportAudience() {\r\n  return useMutation({\r\n    mutationFn: (params?: AudienceExportParams) => cdpApi.exportAudience(params),\r\n  });\r\n}\r\n\r\n// Analytics Hooks\r\n\r\n/**\r\n * Hook to get event statistics\r\n * @param periodDays Analysis period in days (default 30)\r\n */\r\nexport function useEventStatistics(periodDays?: number, options?: { enabled?: boolean }) {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.eventStatistics(periodDays),\r\n    queryFn: () => cdpApi.getEventStatistics(periodDays),\r\n    staleTime: 5 * 60 * 1000, // 5 minutes\r\n    enabled: options?.enabled ?? true,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to get event trends (period-over-period comparison)\r\n * @param periodDays Period in days for comparison (default 7)\r\n */\r\nexport function useEventTrends(periodDays?: number, options?: { enabled?: boolean }) {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.eventTrends(periodDays),\r\n    queryFn: () => cdpApi.getEventTrends(periodDays),\r\n    staleTime: 5 * 60 * 1000, // 5 minutes\r\n    enabled: options?.enabled ?? true,\r\n  });\r\n}\r\n\r\n/**\r\n * Hook to get profile statistics\r\n */\r\nexport function useProfileStatistics(options?: { enabled?: boolean }) {\r\n  return useQuery({\r\n    queryKey: cdpQueryKeys.profileStatistics(),\r\n    queryFn: () => cdpApi.getProfileStatistics(),\r\n    staleTime: 5 * 60 * 1000, // 5 minutes\r\n    enabled: options?.enabled ?? true,\r\n  });\r\n}\r\n\r\n// =============================================================================\r\n// Utility Functions\r\n// =============================================================================\r\n\r\n/**\r\n * Create a track event helper for easy event ingestion\r\n */\r\nexport function createTracker(sourceKey?: string) {\r\n  return {\r\n    track: async (\r\n      eventName: string,\r\n      identifiers: IdentifierInput[],\r\n      properties?: Record<string, unknown>,\r\n      options?: {\r\n        idempotencyKey?: string;\r\n        context?: EventContext;\r\n        consent?: EventConsent;\r\n      }\r\n    ): Promise<EventIngestResult> => {\r\n      const event: EventInput = {\r\n        event_name: eventName,\r\n        event_time: new Date().toISOString(),\r\n        idempotency_key: options?.idempotencyKey,\r\n        identifiers,\r\n        properties,\r\n        context: options?.context,\r\n        consent: options?.consent,\r\n      };\r\n      return cdpApi.ingestEvent(event, sourceKey);\r\n    },\r\n\r\n    identify: async (\r\n      identifiers: IdentifierInput[],\r\n      traits?: Record<string, unknown>\r\n    ): Promise<EventIngestResult> => {\r\n      const event: EventInput = {\r\n        event_name: 'Identify',\r\n        event_time: new Date().toISOString(),\r\n        identifiers,\r\n        properties: traits ? { traits } : undefined,\r\n      };\r\n      return cdpApi.ingestEvent(event, sourceKey);\r\n    },\r\n\r\n    page: async (\r\n      identifiers: IdentifierInput[],\r\n      pageName?: string,\r\n      properties?: Record<string, unknown>,\r\n      context?: EventContext\r\n    ): Promise<EventIngestResult> => {\r\n      const event: EventInput = {\r\n        event_name: 'PageView',\r\n        event_time: new Date().toISOString(),\r\n        identifiers,\r\n        properties: { page_name: pageName, ...properties },\r\n        context,\r\n      };\r\n      return cdpApi.ingestEvent(event, sourceKey);\r\n    },\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// Audience Sync Types\r\n// =============================================================================\r\n\r\nexport type SyncPlatform = 'meta' | 'google' | 'tiktok' | 'snapchat';\r\nexport type SyncStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'partial';\r\nexport type SyncOperation = 'create' | 'update' | 'replace' | 'delete';\r\n\r\nexport interface PlatformAudience {\r\n  id: string;\r\n  segment_id: string;\r\n  platform: SyncPlatform;\r\n  platform_audience_id: string | null;\r\n  platform_audience_name: string;\r\n  ad_account_id: string;\r\n  description: string | null;\r\n  auto_sync: boolean;\r\n  sync_interval_hours: number;\r\n  is_active: boolean;\r\n  last_sync_at: string | null;\r\n  last_sync_status: SyncStatus | null;\r\n  platform_size: number | null;\r\n  matched_size: number | null;\r\n  match_rate: number | null;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface SyncJob {\r\n  id: string;\r\n  platform_audience_id: string;\r\n  operation: SyncOperation;\r\n  status: SyncStatus;\r\n  started_at: string | null;\r\n  completed_at: string | null;\r\n  duration_ms: number | null;\r\n  profiles_total: number;\r\n  profiles_sent: number;\r\n  profiles_added: number;\r\n  profiles_removed: number;\r\n  profiles_failed: number;\r\n  error_message: string | null;\r\n  triggered_by: string | null;\r\n  created_at: string;\r\n}\r\n\r\nexport interface ConnectedPlatform {\r\n  platform: SyncPlatform;\r\n  ad_accounts: Array<{\r\n    ad_account_id: string;\r\n    ad_account_name: string | null;\r\n  }>;\r\n}\r\n\r\nexport interface PlatformAudienceCreate {\r\n  segment_id: string;\r\n  platform: SyncPlatform;\r\n  ad_account_id: string;\r\n  audience_name: string;\r\n  description?: string;\r\n  auto_sync?: boolean;\r\n  sync_interval_hours?: number;\r\n}\r\n\r\nexport interface PlatformAudienceListResponse {\r\n  audiences: PlatformAudience[];\r\n  total: number;\r\n}\r\n\r\nexport interface SyncHistoryResponse {\r\n  jobs: SyncJob[];\r\n}\r\n\r\n// =============================================================================\r\n// Audience Sync API\r\n// =============================================================================\r\n\r\nexport const audienceSyncApi = {\r\n  // Get connected platforms\r\n  getConnectedPlatforms: async (): Promise<ConnectedPlatform[]> => {\r\n    const response = await apiClient.get<ApiResponse<ConnectedPlatform[]>>(\r\n      '/cdp/audience-sync/platforms'\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  // List platform audiences\r\n  listPlatformAudiences: async (params?: {\r\n    segment_id?: string;\r\n    platform?: SyncPlatform;\r\n    limit?: number;\r\n    offset?: number;\r\n  }): Promise<PlatformAudienceListResponse> => {\r\n    const response = await apiClient.get<ApiResponse<PlatformAudienceListResponse>>(\r\n      '/cdp/audience-sync/audiences',\r\n      { params }\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  // Create platform audience\r\n  createPlatformAudience: async (data: PlatformAudienceCreate): Promise<PlatformAudience> => {\r\n    const response = await apiClient.post<ApiResponse<PlatformAudience>>(\r\n      '/cdp/audience-sync/audiences',\r\n      data\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  // Get platform audience\r\n  getPlatformAudience: async (audienceId: string): Promise<PlatformAudience> => {\r\n    const response = await apiClient.get<ApiResponse<PlatformAudience>>(\r\n      `/cdp/audience-sync/audiences/${audienceId}`\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  // Trigger sync\r\n  triggerSync: async (\r\n    audienceId: string,\r\n    operation: 'update' | 'replace' = 'update'\r\n  ): Promise<SyncJob> => {\r\n    const response = await apiClient.post<ApiResponse<SyncJob>>(\r\n      `/cdp/audience-sync/audiences/${audienceId}/sync`,\r\n      { operation }\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  // Get sync history\r\n  getSyncHistory: async (audienceId: string, limit?: number): Promise<SyncHistoryResponse> => {\r\n    const response = await apiClient.get<ApiResponse<SyncHistoryResponse>>(\r\n      `/cdp/audience-sync/audiences/${audienceId}/history`,\r\n      { params: { limit } }\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  // Delete platform audience\r\n  deletePlatformAudience: async (audienceId: string, deleteFromPlatform = true): Promise<void> => {\r\n    await apiClient.delete(`/cdp/audience-sync/audiences/${audienceId}`, {\r\n      params: { delete_from_platform: deleteFromPlatform },\r\n    });\r\n  },\r\n\r\n  // Get segment audiences\r\n  getSegmentAudiences: async (segmentId: string): Promise<PlatformAudienceListResponse> => {\r\n    const response = await apiClient.get<ApiResponse<PlatformAudienceListResponse>>(\r\n      `/cdp/audience-sync/segments/${segmentId}/audiences`\r\n    );\r\n    return response.data.data;\r\n  },\r\n\r\n  // Sync segment to all platforms\r\n  syncSegmentToAllPlatforms: async (\r\n    segmentId: string,\r\n    operation: 'update' | 'replace' = 'update'\r\n  ): Promise<SyncJob[]> => {\r\n    const response = await apiClient.post<ApiResponse<SyncJob[]>>(\r\n      `/cdp/audience-sync/segments/${segmentId}/sync-all`,\r\n      null,\r\n      { params: { operation } }\r\n    );\r\n    return response.data.data;\r\n  },\r\n};\r\n\r\n// =============================================================================\r\n// Audience Sync Hooks\r\n// =============================================================================\r\n\r\nexport function useConnectedPlatforms() {\r\n  return useQuery({\r\n    queryKey: [...cdpQueryKeys.all, 'connected-platforms'],\r\n    queryFn: () => audienceSyncApi.getConnectedPlatforms(),\r\n  });\r\n}\r\n\r\nexport function usePlatformAudiences(params?: {\r\n  segment_id?: string;\r\n  platform?: SyncPlatform;\r\n  limit?: number;\r\n  offset?: number;\r\n}) {\r\n  return useQuery({\r\n    queryKey: [...cdpQueryKeys.all, 'platform-audiences', params],\r\n    queryFn: () => audienceSyncApi.listPlatformAudiences(params),\r\n  });\r\n}\r\n\r\nexport function useSegmentAudiences(segmentId: string) {\r\n  return useQuery({\r\n    queryKey: [...cdpQueryKeys.all, 'segment-audiences', segmentId],\r\n    queryFn: () => audienceSyncApi.getSegmentAudiences(segmentId),\r\n    enabled: !!segmentId,\r\n  });\r\n}\r\n\r\nexport function useSyncHistory(audienceId: string, limit?: number) {\r\n  return useQuery({\r\n    queryKey: [...cdpQueryKeys.all, 'sync-history', audienceId, limit],\r\n    queryFn: () => audienceSyncApi.getSyncHistory(audienceId, limit),\r\n    enabled: !!audienceId,\r\n  });\r\n}\r\n\r\nexport function useCreatePlatformAudience() {\r\n  const queryClient = useQueryClient();\r\n  return useMutation({\r\n    mutationFn: (data: PlatformAudienceCreate) => audienceSyncApi.createPlatformAudience(data),\r\n    onSuccess: () => {\r\n      queryClient.invalidateQueries({ queryKey: [...cdpQueryKeys.all, 'platform-audiences'] });\r\n      queryClient.invalidateQueries({ queryKey: [...cdpQueryKeys.all, 'segment-audiences'] });\r\n    },\r\n  });\r\n}\r\n\r\nexport function useTriggerSync() {\r\n  const queryClient = useQueryClient();\r\n  return useMutation({\r\n    mutationFn: ({\r\n      audienceId,\r\n      operation,\r\n    }: {\r\n      audienceId: string;\r\n      operation?: 'update' | 'replace';\r\n    }) => audienceSyncApi.triggerSync(audienceId, operation),\r\n    onSuccess: (_, { audienceId }) => {\r\n      queryClient.invalidateQueries({\r\n        queryKey: [...cdpQueryKeys.all, 'sync-history', audienceId],\r\n      });\r\n      queryClient.invalidateQueries({\r\n        queryKey: [...cdpQueryKeys.all, 'platform-audiences'],\r\n      });\r\n    },\r\n  });\r\n}\r\n\r\nexport function useDeletePlatformAudience() {\r\n  const queryClient = useQueryClient();\r\n  return useMutation({\r\n    mutationFn: ({\r\n      audienceId,\r\n      deleteFromPlatform,\r\n    }: {\r\n      audienceId: string;\r\n      deleteFromPlatform?: boolean;\r\n    }) => audienceSyncApi.deletePlatformAudience(audienceId, deleteFromPlatform),\r\n    onSuccess: () => {\r\n      queryClient.invalidateQueries({ queryKey: [...cdpQueryKeys.all, 'platform-audiences'] });\r\n      queryClient.invalidateQueries({ queryKey: [...cdpQueryKeys.all, 'segment-audiences'] });\r\n    },\r\n  });\r\n}\r\n\r\nexport function useSyncSegmentToAllPlatforms() {\r\n  const queryClient = useQueryClient();\r\n  return useMutation({\r\n    mutationFn: ({\r\n      segmentId,\r\n      operation,\r\n    }: {\r\n      segmentId: string;\r\n      operation?: 'update' | 'replace';\r\n    }) => audienceSyncApi.syncSegmentToAllPlatforms(segmentId, operation),\r\n    onSuccess: () => {\r\n      queryClient.invalidateQueries({ queryKey: [...cdpQueryKeys.all, 'platform-audiences'] });\r\n      queryClient.invalidateQueries({ queryKey: [...cdpQueryKeys.all, 'sync-history'] });\r\n    },\r\n  });\r\n}\r\n"],"names":["cdpApi","events","sourceKey","params","apiClient","event","profileId","identifierType","identifierValue","source","webhook","webhookId","update","request","segment","segmentId","trait","traitId","config","funnel","funnelId","step","period_days","cdpQueryKeys","id","type","value","periodDays","useCDPProfile","options","useQuery","useCDPHealth","useEventAnomalies","useAnomalySummary","useIdentityGraph","useProfileMergeHistory","useSegments","useCreateSegment","queryClient","useQueryClient","useMutation","useUpdateSegment","_","useDeleteSegment","useComputeSegment","usePreviewSegment","useComputedTraits","useCreateComputedTrait","useDeleteComputedTrait","useProfileRFM","useComputeRFMBatch","useRFMSummary","useFunnels","useCreateFunnel","useUpdateFunnel","useDeleteFunnel","useComputeFunnel","useAnalyzeFunnel","useFunnelDropOffs","useSearchProfiles","useExportAudience","useEventStatistics","useEventTrends","useProfileStatistics","audienceSyncApi","data","audienceId","operation","limit","deleteFromPlatform","useConnectedPlatforms","usePlatformAudiences","useSyncHistory","useCreatePlatformAudience","useTriggerSync","useDeletePlatformAudience"],"mappings":"qGAs3BO,MAAMA,EAAS,CAOpB,aAAc,MAAOC,EAAsBC,IAAoD,CAC7F,MAAMC,EAASD,EAAY,CAAE,WAAYA,CAAA,EAAc,CAAA,EAMvD,OALiB,MAAME,EAAU,KAC/B,cACA,CAAE,OAAAH,CAAA,EACF,CAAE,OAAAE,CAAA,CAAO,GAEK,KAAK,IACvB,EAOA,YAAa,MAAOE,EAAmBH,KACpB,MAAMF,EAAO,aAAa,CAACK,CAAK,EAAGH,CAAS,GAC7C,QAAQ,CAAC,EAQ3B,WAAY,MAAOI,IACA,MAAMF,EAAU,IAA6B,iBAAiBE,CAAS,EAAE,GAC1E,KAAK,KAQvB,cAAe,MACbC,EACAC,KAEiB,MAAMJ,EAAU,IAA6B,gBAAiB,CAC7E,OAAQ,CACN,gBAAiBG,EACjB,iBAAkBC,CAAA,CACpB,CACD,GACe,KAAK,KAOvB,YAAa,UACM,MAAMJ,EAAU,IAAqC,cAAc,GACpE,KAAK,KAOvB,aAAc,MAAOK,IACF,MAAML,EAAU,KAA6B,eAAgBK,CAAM,GACpE,KAAK,KAOvB,OAAQ,UACW,MAAML,EAAU,IAAuB,aAAa,GACrD,KAOlB,aAAc,UACK,MAAMA,EAAU,IAAsC,eAAe,GACtE,KAAK,KAOvB,cAAe,MAAOM,IACH,MAAMN,EAAU,KAA8B,gBAAiBM,CAAO,GACvE,KAAK,KAOvB,WAAY,MAAOC,IACA,MAAMP,EAAU,IAA6B,iBAAiBO,CAAS,EAAE,GAC1E,KAAK,KAQvB,cAAe,MAAOA,EAAmBC,KACtB,MAAMR,EAAU,MAC/B,iBAAiBO,CAAS,GAC1BC,CAAA,GAEc,KAAK,KAOvB,cAAe,MAAOD,GAAqC,CACzD,MAAMP,EAAU,OAAO,iBAAiBO,CAAS,EAAE,CACrD,EAMA,YAAa,MAAOA,IACD,MAAMP,EAAU,KAC/B,iBAAiBO,CAAS,OAAA,GAEZ,KAAK,KAOvB,oBAAqB,MAAOA,IACT,MAAMP,EAAU,KAC/B,iBAAiBO,CAAS,gBAAA,GAEZ,KAAK,KAQvB,qBAAsB,MACpBR,IAEiB,MAAMC,EAAU,IAA8B,wBAAyB,CACtF,OAAAD,CAAA,CACD,GACe,KAMlB,kBAAmB,UACA,MAAMC,EAAU,IAA4B,wBAAwB,GACrE,KAQlB,eAAgB,MACdD,KAEeA,GAAA,YAAAA,EAAQ,SAAU,UAElB,OACI,MAAMC,EAAU,IAAI,uBAAwB,CAC3D,OAAQ,CAAE,GAAGD,EAAQ,OAAQ,KAAA,EAC7B,aAAc,MAAA,CACf,GACe,MAGD,MAAMC,EAAU,IAAgC,uBAAwB,CACvF,OAAAD,CAAA,CACD,GACe,KAOlB,aAAc,MAAOA,KACJA,GAAA,YAAAA,EAAQ,SAAU,UAElB,OACI,MAAMC,EAAU,IAAI,qBAAsB,CACzD,OAAQ,CAAE,GAAGD,EAAQ,OAAQ,KAAA,EAC7B,aAAc,MAAA,CACf,GACe,MAGD,MAAMC,EAAU,IAA8B,qBAAsB,CACnF,OAAAD,CAAA,CACD,GACe,KAQlB,iBAAkB,MAAOG,IACN,MAAMF,EAAU,IAC/B,iBAAiBE,CAAS,iBAAA,GAEZ,KAAK,KAOvB,qBAAsB,MAAOA,IACV,MAAMF,EAAU,IAC/B,iBAAiBE,CAAS,qBAAA,GAEZ,KAAK,KAOvB,uBAAwB,MAAOA,IACZ,MAAMF,EAAU,IAC/B,iBAAiBE,CAAS,gBAAA,GAEZ,KAAK,KAOvB,cAAe,MAAOO,IACH,MAAMT,EAAU,KAC/B,sBACAS,CAAA,GAEc,KAAK,KAOvB,iBAAkB,MAAOV,IAIN,MAAMC,EAAU,IAC/B,qBACA,CAAE,OAAAD,CAAA,CAAO,GAEK,KAAK,KAOvB,kBAAmB,MAAOA,IAKP,MAAMC,EAAU,IAA2B,sBAAuB,CAAE,OAAAD,EAAQ,GAC7E,KAOlB,cAAe,MAAOW,IACH,MAAMV,EAAU,KAA8B,gBAAiBU,CAAO,GACvE,KAAK,KAMvB,aAAc,MAAOX,IAMF,MAAMC,EAAU,IAAsC,gBAAiB,CACtF,OAAAD,CAAA,CACD,GACe,KAAK,KAMvB,WAAY,MAAOY,IACA,MAAMX,EAAU,IAA6B,iBAAiBW,CAAS,EAAE,GAC1E,KAAK,KAMvB,cAAe,MAAOA,EAAmBH,KACtB,MAAMR,EAAU,MAC/B,iBAAiBW,CAAS,GAC1BH,CAAA,GAEc,KAAK,KAMvB,cAAe,MAAOG,GAAqC,CACzD,MAAMX,EAAU,OAAO,iBAAiBW,CAAS,EAAE,CACrD,EAKA,eAAgB,MAAOA,IACJ,MAAMX,EAAU,KAC/B,iBAAiBW,CAAS,UAAA,GAEZ,KAAK,KAMvB,eAAgB,MAAOF,IACJ,MAAMT,EAAU,KAC/B,wBACAS,CAAA,GAEc,KAAK,KAMvB,mBAAoB,MAClBE,EACAZ,KAKiB,MAAMC,EAAU,IAC/B,iBAAiBW,CAAS,YAC1B,CAAE,OAAAZ,CAAA,CAAO,GAEK,KAAK,KAMvB,mBAAoB,MAAOG,IACR,MAAMF,EAAU,IAC/B,iBAAiBE,CAAS,WAAA,GAEZ,KAAK,KAMvB,cAAe,MACbA,EACAH,KAKiB,MAAMC,EAAU,OAC/B,iBAAiBE,CAAS,GAC1B,CAAE,OAAAH,CAAA,CAAO,GAEK,KAAK,KAOvB,YAAa,MAAOa,IACD,MAAMZ,EAAU,KAAoC,cAAeY,CAAK,GACzE,KAAK,KAMvB,WAAY,MAAOb,IAKA,MAAMC,EAAU,IAA4C,cAAe,CAC1F,OAAAD,CAAA,CACD,GACe,KAAK,KAMvB,SAAU,MAAOc,IACE,MAAMb,EAAU,IAAmC,eAAea,CAAO,EAAE,GAC5E,KAAK,KAMvB,YAAa,MAAOA,GAAmC,CACrD,MAAMb,EAAU,OAAO,eAAea,CAAO,EAAE,CACjD,EAKA,iBAAkB,UAEd,MAAMb,EAAU,KAAyC,qBAAqB,GAChE,KAAK,KAMvB,qBAAsB,MACpBE,IAEiB,MAAMF,EAAU,KAE/B,iBAAiBE,CAAS,iBAAiB,GAC7B,KAAK,KAOvB,cAAe,MAAOA,EAAmBH,KACtB,MAAMC,EAAU,IAA4B,iBAAiBE,CAAS,OAAQ,CAC7F,OAAAH,CAAA,CACD,GACe,KAAK,KAMvB,gBAAiB,MAAOe,IACL,MAAMd,EAAU,KAC/B,mBACAc,CAAA,GAEc,KAAK,KAMvB,cAAe,UACI,MAAMd,EAAU,IAAqC,kBAAkB,GACxE,KAAK,KAOvB,aAAc,MAAOe,IACF,MAAMf,EAAU,KAA6B,eAAgBe,CAAM,GACpE,KAAK,KAMvB,YAAa,MAAOhB,IAKD,MAAMC,EAAU,IAAqC,eAAgB,CACpF,OAAAD,CAAA,CACD,GACe,KAAK,KAMvB,UAAW,MAAOiB,IACC,MAAMhB,EAAU,IAA4B,gBAAgBgB,CAAQ,EAAE,GACvE,KAAK,KAMvB,aAAc,MAAOA,EAAkBR,KACpB,MAAMR,EAAU,MAC/B,gBAAgBgB,CAAQ,GACxBR,CAAA,GAEc,KAAK,KAMvB,aAAc,MAAOQ,GAAoC,CACvD,MAAMhB,EAAU,OAAO,gBAAgBgB,CAAQ,EAAE,CACnD,EAKA,cAAe,MAAOA,IACH,MAAMhB,EAAU,KAC/B,gBAAgBgB,CAAQ,UAAA,GAEV,KAAK,KAMvB,cAAe,MACbA,EACAjB,KAEiB,MAAMC,EAAU,KAC/B,gBAAgBgB,CAAQ,WACxBjB,CAAA,GAEc,KAAK,KAMvB,kBAAmB,MACjBiB,EACAC,EACAlB,KAEiB,MAAMC,EAAU,IAC/B,gBAAgBgB,CAAQ,cAAcC,CAAI,GAC1C,CAAE,OAAAlB,CAAA,CAAO,GAEK,KAAK,KAMvB,yBAA0B,MACxBG,EACAc,KAEiB,MAAMhB,EAAU,IAC/B,iBAAiBE,CAAS,WAC1B,CAAE,OAAQc,EAAW,CAAE,UAAWA,CAAA,EAAa,MAAA,CAAU,GAE3C,KAAK,KAQvB,mBAAoB,MAAOE,IACR,MAAMlB,EAAU,IAA6B,yBAA0B,CACtF,OAAQkB,EAAc,CAAE,YAAAA,GAAgB,MAAA,CACzC,GACe,KAOlB,eAAgB,MAAOA,IACJ,MAAMlB,EAAU,IAAyB,qBAAsB,CAC9E,OAAQkB,EAAc,CAAE,YAAAA,GAAgB,MAAA,CACzC,GACe,KAMlB,qBAAsB,UACH,MAAMlB,EAAU,IAA+B,0BAA0B,GAC1E,KAQlB,eAAgB,MAAOD,IACJ,MAAMC,EAAU,KAA4B,uBAAwB,KAAM,CACzF,OAAAD,CAAA,CACD,GACe,KAQlB,eAAgB,MAAOA,KACNA,GAAA,YAAAA,EAAQ,SAAU,UAElB,OACI,MAAMC,EAAU,KAAK,wBAAyB,KAAM,CACnE,OAAQ,CAAE,GAAGD,EAAQ,OAAQ,KAAA,EAC7B,aAAc,MAAA,CACf,GACe,MAGD,MAAMC,EAAU,KAA6B,wBAAyB,KAAM,CAC3F,OAAAD,CAAA,CACD,GACe,IAEpB,EAOaoB,EAAe,CAC1B,IAAK,CAAC,KAAK,EACX,SAAU,IAAM,CAAC,GAAGA,EAAa,IAAK,UAAU,EAChD,QAAUC,GAAe,CAAC,GAAGD,EAAa,SAAA,EAAYC,CAAE,EACxD,oBAAqB,CAACC,EAAsBC,IAC1C,CAAC,GAAGH,EAAa,WAAY,SAAUE,EAAMC,CAAK,EACpD,QAAS,IAAM,CAAC,GAAGH,EAAa,IAAK,SAAS,EAC9C,OAAQ,IAAM,CAAC,GAAGA,EAAa,IAAK,QAAQ,EAC5C,SAAU,IAAM,CAAC,GAAGA,EAAa,IAAK,UAAU,EAChD,QAAUC,GAAe,CAAC,GAAGD,EAAa,SAAA,EAAYC,CAAE,EACxD,UAAW,IAAM,CAAC,GAAGD,EAAa,IAAK,WAAW,EAClD,eAAgB,IAAM,CAAC,GAAGA,EAAa,UAAA,EAAa,SAAS,EAC7D,cAAgBjB,GACd,CAAC,GAAGiB,EAAa,SAAA,EAAYjB,EAAW,gBAAgB,EAC1D,kBAAoBA,GAClB,CAAC,GAAGiB,EAAa,SAAA,EAAYjB,EAAW,WAAW,EACrD,oBAAsBA,GACpB,CAAC,GAAGiB,EAAa,SAAA,EAAYjB,EAAW,eAAe,EACzD,aAAc,IAAM,CAAC,GAAGiB,EAAa,IAAK,eAAe,EACzD,cAAe,IAAM,CAAC,GAAGA,EAAa,IAAK,gBAAgB,EAC3D,SAAU,IAAM,CAAC,GAAGA,EAAa,IAAK,UAAU,EAChD,QAAUC,GAAe,CAAC,GAAGD,EAAa,SAAA,EAAYC,CAAE,EACxD,gBAAkBA,GAAe,CAAC,GAAGD,EAAa,SAAA,EAAYC,EAAI,UAAU,EAC5E,gBAAkBlB,GAChB,CAAC,GAAGiB,EAAa,SAAA,EAAYjB,EAAW,UAAU,EACpD,OAAQ,IAAM,CAAC,GAAGiB,EAAa,IAAK,QAAQ,EAC5C,MAAQC,GAAe,CAAC,GAAGD,EAAa,OAAA,EAAUC,CAAE,EACpD,WAAalB,GAAsB,CAAC,GAAGiB,EAAa,SAAA,EAAYjB,EAAW,KAAK,EAChF,WAAY,IAAM,CAAC,GAAGiB,EAAa,IAAK,aAAa,EACrD,QAAS,IAAM,CAAC,GAAGA,EAAa,IAAK,SAAS,EAC9C,OAASC,GAAe,CAAC,GAAGD,EAAa,QAAA,EAAWC,CAAE,EACtD,eAAgB,CAACA,EAAYH,IAC3B,CAAC,GAAGE,EAAa,UAAWC,EAAI,YAAaH,CAAI,EACnD,eAAiBf,GACf,CAAC,GAAGiB,EAAa,SAAA,EAAYjB,EAAW,SAAS,EACnD,cAAe,IAAM,CAAC,GAAGiB,EAAa,SAAA,EAAY,QAAQ,EAE1D,gBAAkBI,GAChB,CAAC,GAAGJ,EAAa,IAAK,mBAAoBI,CAAU,EACtD,YAAcA,GAAwB,CAAC,GAAGJ,EAAa,IAAK,eAAgBI,CAAU,EACtF,kBAAmB,IAAM,CAAC,GAAGJ,EAAa,IAAK,oBAAoB,CACrE,EAKO,SAASK,EAActB,EAAmBuB,EAAiC,CAChF,OAAOC,EAAS,CACd,SAAUP,EAAa,QAAQjB,CAAS,EACxC,QAAS,IAAMN,EAAO,WAAWM,CAAS,EAC1C,UAAW,GAAK,IAChB,SAASuB,GAAA,YAAAA,EAAS,UAAW,CAAC,CAACvB,CAAA,CAChC,CACH,CA4EO,SAASyB,GAAe,CAC7B,OAAOD,EAAS,CACd,SAAUP,EAAa,OAAA,EACvB,QAAS,IAAMvB,EAAO,OAAA,EACtB,UAAW,GAAK,IAChB,gBAAiB,EAAI,GAAK,GAAA,CAC3B,CACH,CA+FO,SAASgC,EAAkB7B,EAAiC,CACjE,OAAO2B,EAAS,CACd,SAAU,CAAC,GAAGP,EAAa,UAAA,EAAapB,CAAM,EAC9C,QAAS,IAAMH,EAAO,qBAAqBG,CAAM,EACjD,UAAW,EAAI,GAAK,GAAA,CACrB,CACH,CAKO,SAAS8B,GAAoB,CAClC,OAAOH,EAAS,CACd,SAAUP,EAAa,eAAA,EACvB,QAAS,IAAMvB,EAAO,kBAAA,EACtB,UAAW,GAAK,IAChB,gBAAiB,EAAI,GAAK,GAAA,CAC3B,CACH,CAKO,SAASkC,EAAiB5B,EAAmBuB,EAAiC,CACnF,OAAOC,EAAS,CACd,SAAUP,EAAa,cAAcjB,CAAS,EAC9C,QAAS,IAAMN,EAAO,iBAAiBM,CAAS,EAChD,UAAW,GAAK,IAChB,SAASuB,GAAA,YAAAA,EAAS,UAAW,CAAC,CAACvB,CAAA,CAChC,CACH,CAiBO,SAAS6B,EAAuB7B,EAAmBuB,EAAiC,CACzF,OAAOC,EAAS,CACd,SAAUP,EAAa,oBAAoBjB,CAAS,EACpD,QAAS,IAAMN,EAAO,uBAAuBM,CAAS,EACtD,UAAW,GAAK,IAChB,QAA6B,CAAC,CAACA,CAAA,CAChC,CACH,CAmDO,SAAS8B,EAAYjC,EAKzB,CACD,OAAO2B,EAAS,CACd,SAAU,CAAC,GAAGP,EAAa,SAAA,EAAYpB,CAAM,EAC7C,QAAS,IAAMH,EAAO,aAAaG,CAAM,EACzC,UAAW,GAAK,GAAA,CACjB,CACH,CAiBO,SAASkC,GAAmB,CACjC,MAAMC,EAAcC,EAAA,EAEpB,OAAOC,EAAY,CACjB,WAAa1B,GAA2Bd,EAAO,cAAcc,CAAO,EACpE,UAAW,IAAM,CACfwB,EAAY,kBAAkB,CAAE,SAAUf,EAAa,SAAA,EAAY,CACrE,CAAA,CACD,CACH,CAKO,SAASkB,GAAmB,CACjC,MAAMH,EAAcC,EAAA,EAEpB,OAAOC,EAAY,CACjB,WAAY,CAAC,CAAE,UAAAzB,EAAW,OAAAH,KACxBZ,EAAO,cAAce,EAAWH,CAAM,EACxC,UAAW,CAAC8B,EAAG,CAAE,UAAA3B,KAAgB,CAC/BuB,EAAY,kBAAkB,CAAE,SAAUf,EAAa,SAAA,EAAY,EACnEe,EAAY,kBAAkB,CAAE,SAAUf,EAAa,QAAQR,CAAS,EAAG,CAC7E,CAAA,CACD,CACH,CAKO,SAAS4B,GAAmB,CACjC,MAAML,EAAcC,EAAA,EAEpB,OAAOC,EAAY,CACjB,WAAazB,GAAsBf,EAAO,cAAce,CAAS,EACjE,UAAW,IAAM,CACfuB,EAAY,kBAAkB,CAAE,SAAUf,EAAa,SAAA,EAAY,CACrE,CAAA,CACD,CACH,CAKO,SAASqB,GAAoB,CAClC,MAAMN,EAAcC,EAAA,EAEpB,OAAOC,EAAY,CACjB,WAAazB,GAAsBf,EAAO,eAAee,CAAS,EAClE,UAAW,CAAC2B,EAAG3B,IAAc,CAC3BuB,EAAY,kBAAkB,CAAE,SAAUf,EAAa,QAAQR,CAAS,EAAG,EAC3EuB,EAAY,kBAAkB,CAAE,SAAUf,EAAa,gBAAgBR,CAAS,EAAG,CACrF,CAAA,CACD,CACH,CAKO,SAAS8B,GAAoB,CAClC,OAAOL,EAAY,CACjB,WAAa3B,GAAmCb,EAAO,eAAea,CAAO,CAAA,CAC9E,CACH,CAwDO,SAASiC,EAAkB3C,EAI/B,CACD,OAAO2B,EAAS,CACd,SAAU,CAAC,GAAGP,EAAa,OAAA,EAAUpB,CAAM,EAC3C,QAAS,IAAMH,EAAO,WAAWG,CAAM,EACvC,UAAW,GAAK,GAAA,CACjB,CACH,CAiBO,SAAS4C,GAAyB,CACvC,MAAMT,EAAcC,EAAA,EAEpB,OAAOC,EAAY,CACjB,WAAaxB,GAA+BhB,EAAO,YAAYgB,CAAK,EACpE,UAAW,IAAM,CACfsB,EAAY,kBAAkB,CAAE,SAAUf,EAAa,OAAA,EAAU,CACnE,CAAA,CACD,CACH,CAKO,SAASyB,GAAyB,CACvC,MAAMV,EAAcC,EAAA,EAEpB,OAAOC,EAAY,CACjB,WAAavB,GAAoBjB,EAAO,YAAYiB,CAAO,EAC3D,UAAW,IAAM,CACfqB,EAAY,kBAAkB,CAAE,SAAUf,EAAa,OAAA,EAAU,CACnE,CAAA,CACD,CACH,CAqBO,SAAS0B,EACd3C,EACAH,EACA0B,EACA,CACA,OAAOC,EAAS,CACd,SAAU,CAAC,GAAGP,EAAa,WAAWjB,CAAS,EAAGH,CAAM,EACxD,QAAS,IAAMH,EAAO,cAAcM,EAAWH,CAAM,EACrD,UAAW,EAAI,GAAK,IACpB,QAA6B,CAAC,CAACG,CAAA,CAChC,CACH,CAKO,SAAS4C,GAAqB,CACnC,MAAMZ,EAAcC,EAAA,EAEpB,OAAOC,EAAY,CACjB,WAAatB,GAAuBlB,EAAO,gBAAgBkB,CAAM,EACjE,UAAW,IAAM,CACfoB,EAAY,kBAAkB,CAAE,SAAUf,EAAa,SAAA,EAAY,EACnEe,EAAY,kBAAkB,CAAE,SAAUf,EAAa,WAAA,EAAc,CACvE,CAAA,CACD,CACH,CAKO,SAAS4B,GAAgB,CAC9B,OAAOrB,EAAS,CACd,SAAUP,EAAa,WAAA,EACvB,QAAS,IAAMvB,EAAO,cAAA,EACtB,UAAW,EAAI,GAAK,GAAA,CACrB,CACH,CAOO,SAASoD,EAAWjD,EAAqE,CAC9F,OAAO2B,EAAS,CACd,SAAU,CAAC,GAAGP,EAAa,QAAA,EAAWpB,CAAM,EAC5C,QAAS,IAAMH,EAAO,YAAYG,CAAM,EACxC,UAAW,GAAK,GAAA,CACjB,CACH,CAiBO,SAASkD,GAAkB,CAChC,MAAMf,EAAcC,EAAA,EAEpB,OAAOC,EAAY,CACjB,WAAarB,GAAyBnB,EAAO,aAAamB,CAAM,EAChE,UAAW,IAAM,CACfmB,EAAY,kBAAkB,CAAE,SAAUf,EAAa,QAAA,EAAW,CACpE,CAAA,CACD,CACH,CAKO,SAAS+B,GAAkB,CAChC,MAAMhB,EAAcC,EAAA,EAEpB,OAAOC,EAAY,CACjB,WAAY,CAAC,CAAE,SAAApB,EAAU,OAAAR,KACvBZ,EAAO,aAAaoB,EAAUR,CAAM,EACtC,UAAW,CAAC8B,EAAG,CAAE,SAAAtB,KAAe,CAC9BkB,EAAY,kBAAkB,CAAE,SAAUf,EAAa,QAAA,EAAW,EAClEe,EAAY,kBAAkB,CAAE,SAAUf,EAAa,OAAOH,CAAQ,EAAG,CAC3E,CAAA,CACD,CACH,CAKO,SAASmC,GAAkB,CAChC,MAAMjB,EAAcC,EAAA,EAEpB,OAAOC,EAAY,CACjB,WAAapB,GAAqBpB,EAAO,aAAaoB,CAAQ,EAC9D,UAAW,IAAM,CACfkB,EAAY,kBAAkB,CAAE,SAAUf,EAAa,QAAA,EAAW,CACpE,CAAA,CACD,CACH,CAKO,SAASiC,GAAmB,CACjC,MAAMlB,EAAcC,EAAA,EAEpB,OAAOC,EAAY,CACjB,WAAapB,GAAqBpB,EAAO,cAAcoB,CAAQ,EAC/D,UAAW,CAACsB,EAAGtB,IAAa,CAC1BkB,EAAY,kBAAkB,CAAE,SAAUf,EAAa,OAAOH,CAAQ,EAAG,CAC3E,CAAA,CACD,CACH,CAKO,SAASqC,GAAmB,CACjC,OAAOjB,EAAY,CACjB,WAAY,CAAC,CAAE,SAAApB,EAAU,OAAAjB,KACvBH,EAAO,cAAcoB,EAAUjB,CAAM,CAAA,CACxC,CACH,CAKO,SAASuD,EACdtC,EACAC,EACAlB,EACA0B,EACA,CACA,OAAOC,EAAS,CACd,SAAU,CAAC,GAAGP,EAAa,eAAeH,EAAUC,CAAI,EAAGlB,CAAM,EACjE,QAAS,IAAMH,EAAO,kBAAkBoB,EAAUC,EAAMlB,CAAM,EAC9D,UAAW,GAAK,IAChB,SAAS0B,GAAA,YAAAA,EAAS,WAAY,CAAC,CAACT,GAAYC,EAAO,EAAA,CACpD,CACH,CAuBO,SAASsC,EAAkBxD,EAA8B0B,EAAiC,CAC/F,OAAOC,EAAS,CACd,SAAU,CAAC,GAAGP,EAAa,cAAA,EAAiBpB,CAAM,EAClD,QAAS,IAAMH,EAAO,eAAeG,CAAM,EAC3C,UAAW,GAAK,IAChB,QAA6B,EAAA,CAC9B,CACH,CAgBO,SAASyD,GAAoB,CAClC,OAAOpB,EAAY,CACjB,WAAarC,GAAkCH,EAAO,eAAeG,CAAM,CAAA,CAC5E,CACH,CAQO,SAAS0D,EAAmBlC,EAAqBE,EAAiC,CACvF,OAAOC,EAAS,CACd,SAAUP,EAAa,gBAAgBI,CAAU,EACjD,QAAS,IAAM3B,EAAO,mBAAmB2B,CAAU,EACnD,UAAW,EAAI,GAAK,IACpB,QAA6B,EAAA,CAC9B,CACH,CAMO,SAASmC,EAAenC,EAAqBE,EAAiC,CACnF,OAAOC,EAAS,CACd,SAAUP,EAAa,YAAYI,CAAU,EAC7C,QAAS,IAAM3B,EAAO,eAAe2B,CAAU,EAC/C,UAAW,EAAI,GAAK,IACpB,QAA6B,EAAA,CAC9B,CACH,CAKO,SAASoC,EAAqBlC,EAAiC,CACpE,OAAOC,EAAS,CACd,SAAUP,EAAa,kBAAA,EACvB,QAAS,IAAMvB,EAAO,qBAAA,EACtB,UAAW,EAAI,GAAK,IACpB,QAA6B,EAAA,CAC9B,CACH,CA6IO,MAAMgE,EAAkB,CAE7B,sBAAuB,UACJ,MAAM5D,EAAU,IAC/B,8BAAA,GAEc,KAAK,KAIvB,sBAAuB,MAAOD,IAMX,MAAMC,EAAU,IAC/B,+BACA,CAAE,OAAAD,CAAA,CAAO,GAEK,KAAK,KAIvB,uBAAwB,MAAO8D,IACZ,MAAM7D,EAAU,KAC/B,+BACA6D,CAAA,GAEc,KAAK,KAIvB,oBAAqB,MAAOC,IACT,MAAM9D,EAAU,IAC/B,gCAAgC8D,CAAU,EAAA,GAE5B,KAAK,KAIvB,YAAa,MACXA,EACAC,EAAkC,YAEjB,MAAM/D,EAAU,KAC/B,gCAAgC8D,CAAU,QAC1C,CAAE,UAAAC,CAAA,CAAU,GAEE,KAAK,KAIvB,eAAgB,MAAOD,EAAoBE,KACxB,MAAMhE,EAAU,IAC/B,gCAAgC8D,CAAU,WAC1C,CAAE,OAAQ,CAAE,MAAAE,CAAA,CAAM,CAAE,GAEN,KAAK,KAIvB,uBAAwB,MAAOF,EAAoBG,EAAqB,KAAwB,CAC9F,MAAMjE,EAAU,OAAO,gCAAgC8D,CAAU,GAAI,CACnE,OAAQ,CAAE,qBAAsBG,CAAA,CAAmB,CACpD,CACH,EAGA,oBAAqB,MAAOtD,IACT,MAAMX,EAAU,IAC/B,+BAA+BW,CAAS,YAAA,GAE1B,KAAK,KAIvB,0BAA2B,MACzBA,EACAoD,EAAkC,YAEjB,MAAM/D,EAAU,KAC/B,+BAA+BW,CAAS,YACxC,KACA,CAAE,OAAQ,CAAE,UAAAoD,CAAA,CAAU,CAAE,GAEV,KAAK,IAEzB,EAMO,SAASG,GAAwB,CACtC,OAAOxC,EAAS,CACd,SAAU,CAAC,GAAGP,EAAa,IAAK,qBAAqB,EACrD,QAAS,IAAMyC,EAAgB,sBAAA,CAAsB,CACtD,CACH,CAEO,SAASO,EAAqBpE,EAKlC,CACD,OAAO2B,EAAS,CACd,SAAU,CAAC,GAAGP,EAAa,IAAK,qBAAsBpB,CAAM,EAC5D,QAAS,IAAM6D,EAAgB,sBAAsB7D,CAAM,CAAA,CAC5D,CACH,CAUO,SAASqE,EAAeN,EAAoBE,EAAgB,CACjE,OAAOtC,EAAS,CACd,SAAU,CAAC,GAAGP,EAAa,IAAK,eAAgB2C,EAAYE,CAAK,EACjE,QAAS,IAAMJ,EAAgB,eAAeE,EAAYE,CAAK,EAC/D,QAAS,CAAC,CAACF,CAAA,CACZ,CACH,CAEO,SAASO,GAA4B,CAC1C,MAAMnC,EAAcC,EAAA,EACpB,OAAOC,EAAY,CACjB,WAAayB,GAAiCD,EAAgB,uBAAuBC,CAAI,EACzF,UAAW,IAAM,CACf3B,EAAY,kBAAkB,CAAE,SAAU,CAAC,GAAGf,EAAa,IAAK,oBAAoB,EAAG,EACvFe,EAAY,kBAAkB,CAAE,SAAU,CAAC,GAAGf,EAAa,IAAK,mBAAmB,EAAG,CACxF,CAAA,CACD,CACH,CAEO,SAASmD,GAAiB,CAC/B,MAAMpC,EAAcC,EAAA,EACpB,OAAOC,EAAY,CACjB,WAAY,CAAC,CACX,WAAA0B,EACA,UAAAC,CAAA,IAIIH,EAAgB,YAAYE,EAAYC,CAAS,EACvD,UAAW,CAACzB,EAAG,CAAE,WAAAwB,KAAiB,CAChC5B,EAAY,kBAAkB,CAC5B,SAAU,CAAC,GAAGf,EAAa,IAAK,eAAgB2C,CAAU,CAAA,CAC3D,EACD5B,EAAY,kBAAkB,CAC5B,SAAU,CAAC,GAAGf,EAAa,IAAK,oBAAoB,CAAA,CACrD,CACH,CAAA,CACD,CACH,CAEO,SAASoD,GAA4B,CAC1C,MAAMrC,EAAcC,EAAA,EACpB,OAAOC,EAAY,CACjB,WAAY,CAAC,CACX,WAAA0B,EACA,mBAAAG,CAAA,IAIIL,EAAgB,uBAAuBE,EAAYG,CAAkB,EAC3E,UAAW,IAAM,CACf/B,EAAY,kBAAkB,CAAE,SAAU,CAAC,GAAGf,EAAa,IAAK,oBAAoB,EAAG,EACvFe,EAAY,kBAAkB,CAAE,SAAU,CAAC,GAAGf,EAAa,IAAK,mBAAmB,EAAG,CACxF,CAAA,CACD,CACH"}